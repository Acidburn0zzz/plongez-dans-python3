---
title: En compréhension
status: En cours
permalink: comprehensions.html
---
<!DOCTYPE html>
<meta charset=utf-8>
<title>Comprehensions - Dive Into Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 3}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=root value=Search></div></form>
<p>Vous êtes ici : <a href=index.html>Index</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#comprehensions>Plongez dans Python 3</a> <span class=u>&#8227;</span>
<p id=level>Niveau de difficulté : <span class=u title=beginner>&#x2666;&#x2666;&#x2662;&#x2662;&#x2662;</span>
<h1>Comprehensions</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> Notre imagination est étirée à l’extrême, non pas, comme dans la fiction, à imaginer des choses qui n’existent pas vraiment, mais seulement à comprendre ces choses qui sont là. <span class=u>&#x275E;</span><br>&mdash; <a href=http://en.wikiquote.org/wiki/Richard_Feynman>Richard Feynman</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Approfondir</h2>
<p class=f>Tout langage de programmation a cette fonctionnalité, une chose compliquée intentionellement rendue simple. Si vous venez d’un autre langage, vous pourriez facilement la manquer, car votre ancien langage ne la rendait pas simple (parce qu’il était occupé à rendre quelque chose d’autre simple à la place). Ce chapitre vous apprendra à utiliser les listes par compréhension, les dictionnaires par compréhension, et les ensembles par compréhension : ces trois concepts sont centrés autour d’une technique très puissante. Mais d’abord, je vais faire un détour par deux modules qui vous aideront à naviguer à travers votre système de fichiers.

<p class=a>&#x2042;

<h2 id=os>Travailler Avec Des Fichiers Et Des Répertoires.</h2>

<p>Python 3 est fourni avec un module appelé <code>os</code>, ce qui signifie « système d’exploitation ». Le <a href=http://docs.python.org/3.1/library/os.html>module <code>os</code></a> contient une pléthore de fonctions pour obtenir des informations sur &nbsp;&mdash;&nbsp;et dans certains cas pour manipuler&nbsp;&mdash;&nbsp;les répertoires et fichiers locaux, les processus, et les variables d’environnement. Python fait de son mieux pour offrir une <abbr>API</abbr> unifiée pour <a href=installing-python.html>tous les systèmes d’exploitation supportés</a> de façon à ce que vos programmes puissent tourner sur n’importe quel ordinateur avec le moins de code spécifique à une plateforme possible.

<h3 id=getcwd>Le Répertoire De Travail Actuel</h3>

<p>Lorsque vous commencez à vous familiariser avec Python, vous passez beaucoup de temps dans <a href=installing-python.html#idle>le Shell Python</a>. Au cours de ce livre, vous verrez des exemples qui sont présentés de cette façon :

<ol>
<li>Importez un des modules du répertoire <a href=examples/><code>examples</code></a>
<li>Appelez une fonction de ce module
<li>Expliquez le résultat
</ol>

<aside>Il y a toujours un répertoire de travail.</aside>

<p>Si vous ne connaissez pas le répertoire de travail, l’étape 1 va probablement échouer avec une <code>ImportError</code>. Pourquoi ? Parce que Pythonn recherchera le module d’exemple dans <a href=your-first-python-program.html#importsearchpath>le chemin de recherche d’import</a>, mais ne le trouvera pas car le dossier <code>examples</code> n’est pas l’un des répertoires du chemin de recherche. Pour régler ce problème, vous avez deux possibilités :

<ol>
<li>Ajouter le dossier <code>examples</code> au chemin de recherche d’import
<li>Changer le répertoire de travail actuel pour être le dossier <code>examples</code>
</ol>

<p>Le répertoire de travail courant est une propriété invisible que Python conserve en mémoire en permanence. Il y a toujours un répertoire de travail courant, que vous soyiez dans le Shell Python, que vous exécutiez votre script depuis la ligne de commande ou en temps que script CGI quelque part sur un serveur web.

<p>Le module <code>os</code> contient deux fonctions traitant du répertoire d’exécution actuel.

<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>import os</kbd>                                            <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.getcwd())</kbd>                                   <span class=u>&#x2461;</span></a>
<samp>C:\Python31</samp>
<a><samp class=p>>>> </samp><kbd class=pp>os.chdir('/Users/pilgrim/diveintopython3/examples')</kbd>  <span class=u>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.getcwd())</kbd>                                   <span class=u>&#x2463;</span></a>
<samp>C:\Users\pilgrim\diveintopython3\examples</samp></pre>
<ol>
<li>Le module <code>os</code> est fournit avec Python ; vous pouvez l’importer de n’importe où, n’importe quand.
<li>Utilisez la fonction <code>os.getcwd()</code> pour obtenir le répertoire d’exécution. Quand vous utilisez le Shell Python graphique, le répertoire de travail initial est votre répertoire utilisateur. Sous Windows c’est l’endroit où vous avez installé Python, le répertoire par défaut étant <code>c:\Python31</code>. Si vous lancez le Shell Python depuis la ligne de commande, le répertoire de travail initial sera le répertoire d’où vous avez exécuté <code>python3</code>.
<li>Utilisez la fonction <code>os.chdir()</code> pour changer le répertoire de travail courant.
<li>Quand j’ai appellé la fonction <code>os.chdir()</code>, j’ai utilisé un nom de chemin tels que ceux utilisé par Linux (slashs, pas de lettre de lecteur) même si je suis sous Windows. C’est un des cas où Python essaye de palier les différences entre les systèmes d’exploitation.
</ol>

<h3 id=ospath>Travailler Avec Les Noms de Fichiers Et De Répertoires</h3>

<p>Puisque nous sommes en train de parler de répertoires, je voulais vous montrer le module <code>os.path</code>. <code>os.path</code> contient des fonctions pour manipuler les noms de fichiers et de répertoires.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.path.join('/Users/pilgrim/diveintopython3/examples/', 'humansize.py'))</kbd>              <span class=u>&#x2460;</span></a>
<samp>/Users/pilgrim/diveintopython3/examples/humansize.py</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.path.join('/Users/pilgrim/diveintopython3/examples', 'humansize.py'))</kbd>               <span class=u>&#x2461;</span></a>
<samp>/Users/pilgrim/diveintopython3/examples\humansize.py</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.path.expanduser('~'))</kbd>                                                               <span class=u>&#x2462;</span></a>
<samp>c:\Users\pilgrim</samp>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.path.join(os.path.expanduser('~'), 'diveintopython3', 'examples', 'humansize.py'))</kbd>  <span class=u>&#x2463;</span></a>
<samp>c:\Users\pilgrim\diveintopython3\examples\humansize.py</samp></pre>
<ol>
<li>La fonction <code>os.path.join()</code> construit un nom de chemin à partir d’un ou plusieurs noms de chemins partiels. Dans ce cas, il concatène simplement des chaines.
<li>Dans ce cas un peu moins trivial, appeler la fonction <code>os.path.join()</code> ajoutera un backslash supplémentaire à la fin du nom du chemin avant de le joindre au nom du fichier. C’est un backlash plutôt qu’slash, car j’ai construit cet exemple sur Windows. Si vous le faites sur Linux ou Mac OS X, vous verez un slash à la place. Ne vous embêtez pas avec les (anti)slashs, utilisez toujours<code>os.path.join()</code> et laissez Python le faire correctement.
<li>La fonction <code>os.path.expanduser()</code> étendra un chemin qui utilise <code>~</code> pour représenter le dossier personnel d’un utilisateur. Ceci fonctionne sur n’importe quelle plateforme sur laquelle les utilisateurs ont un répertoire personne, y compris Linux, Mac OS X, et Windows. Le chemin retourné n’a pas de slash final, mais la fonction <code>os.path.join()</code> n’en a pas besoin.
<li>En combinant ces deux techniques, vous pouvez facilement construire des chemins pour les répertoires et fichiers dans le répertoire pesonnel de l’utilisateur. La fonction <code>os.path.join()</code> peut prendre autant de paramètres que nécessaire. J’étais aux anges quand j’ai découvert ceci, puisque <code>addSlashIfNecessary()</code> était une de ces stupides petites fonctions que je devais toujous écrire lorsque je construisais ma boîte à outils dans un nouveau langage. N’écrivez <em>pas</em> cette stupide petite fonction en Python ; des personnes intelligentes s’en sont déjà chargées pour vous.
</ol>

<p><code>os.path</code> contient également des fonctions pour séparer les noms de chemins, de répertoires, et de fichiers en plusieurs parties.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>pathname = '/Users/pilgrim/diveintopython3/examples/humansize.py'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>os.path.split(pathname)</kbd>                                        <span class=u>&#x2460;</span></a>
<samp class=pp>('/Users/pilgrim/diveintopython3/examples', 'humansize.py')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>(dirname, filename) = os.path.split(pathname)</kbd>                  <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>dirname</kbd>                                                        <span class=u>&#x2462;</span></a>
<samp class=pp>'/Users/pilgrim/diveintopython3/examples'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>filename</kbd>                                                       <span class=u>&#x2463;</span></a>
<samp class=pp>'humansize.py'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>(shortname, extension) = os.path.splitext(filename)</kbd>            <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp><kbd class=pp>shortname</kbd>
<samp class=pp>'humansize'</samp>
<samp class=p>>>> </samp><kbd class=pp>extension</kbd>
<samp class=pp>'.py'</samp></pre>
<ol>
<li>La fonction <code>split</code> sépare un chemin complet et retourne un doublet contenant le chemin et le nom du fichier.
<li>Vous souvenez-vous de quand je vous ai dit d’utiliser <a href=native-datatypes.html#multivar>l’assignation à plusieurs variables</a> pour retourner plusieurs variables d’une fonction ? La fonction  <code>os.path.split()</code> fait exactement ça. Vous pouvez assigner la valeur de retour de la fonction <code>split</code> à un doublet (un <code>tuple</code> à deux éléments). Chacune des variables recevra la valeur de l’élément correspondant du doublet retourné.
<li>La première variable, <var>dirname</var>, reçoit la valeur du premier élement du doublet retourné par la fonction <code>os.path.split()</code>, le chemin du fichier.
<li>La seconde variable, <var>filename</var>, reçoit la valeur du second élément du doublet retourné par la fonction <code>os.path.split()</code>, le nom du fichier.
<li><code>os.path</code> contient également la fonction <code>os.path.splitext()</code>, qui sépare un nom de fichier et retourne un doublet contenant le nom du fichier, et l’extension du fichier. Vous pouvez utiliser la même technique d’assigner chacune des deux pour séparer les variables.
</ol>

<h3 id=glob>Lister des Répertoires</h3>

<p>Le module <code>glob</code> est un autre outil de la bibliothèque standard de Python. C’est une façon simple de récupérer le contenu d’un répertoire programmatiquement, et d’utiliser le genre de jokers avec lesquels vous êtes probablement déjà familier(ère) si vous avez déjà utilisé la ligne de commande.

<aside>Le module <code>glob</code> utilise des jokers semblable à ceux d’un shell.</aside>

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>os.chdir('/Users/pilgrim/diveintopython3/')</kbd>
<samp class=p>>>> </samp><kbd class=pp>import glob</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>glob.glob('examples/*.xml')</kbd>                  <span class=u>&#x2460;</span></a>
<samp class=pp>['examples\\feed-broken.xml',
 'examples\\feed-ns0.xml',
 'examples\\feed.xml']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>os.chdir('examples/')</kbd>                        <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>glob.glob('*test*.py')</kbd>                       <span class=u>&#x2462;</span></a>
<samp class=pp>['alphameticstest.py',
 'pluraltest1.py',
 'pluraltest2.py',
 'pluraltest3.py',
 'pluraltest4.py',
 'pluraltest5.py',
 'pluraltest6.py',
 'romantest1.py',
 'romantest10.py',
 'romantest2.py',
 'romantest3.py',
 'romantest4.py',
 'romantest5.py',
 'romantest6.py',
 'romantest7.py',
 'romantest8.py',
 'romantest9.py']</samp></pre>
<ol>
<li>Le module <code>glob</code> prend un schéma et retourne les chemins de tous les fichiers et répertoires qui y correspondent. Dans cet exemple, le joker est le chemin du répertoire plus «&nbsp;<code>*.xml</code>&nbsp;», ce qui correspond à tous les fichiers <code>.xml</code> dans le sous-répertoire <code>examples</code>.
<li>À présent nous changeons le répertoire de travail pour qu’il soit <code>examples</code>. La fonction <code>os.chdir()</code> accepte les chemins relatifs.
<li>Vous pouvez inclure plusieurs jokers dans votre schéma glob. Cet exemple trouve tous les fichiers du répertoire de travail courant qui se terminent par l’extension <code>.py</code> et contiennent le mot <code>test</code> n’importe où dans leur nom.
</ol>

<h3 id=osstat>Récupérer les Méta-données d’un Fichier</h3>

<p>Tous les systèmer de fichiers modernes stockent des méta-données à propos de chaque fichier : date de création, de dernière modification, taille du fichier, etc. Python fournit une <abbr>API</abbr> unique pour accéder à ces méta-données. Vous n’avez pas besoin d’ouvrir le fichier ; tout ce dont vous avez besoin est le nom du fichier.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>print(os.getcwd())</kbd>                 <span class=u>&#x2460;</span></a>
<samp class=pp>c:\Users\pilgrim\diveintopython3\examples</samp>
<a><samp class=p>>>> </samp><kbd class=pp>metadata = os.stat('feed.xml')</kbd>     <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>metadata.st_mtime</kbd>                  <span class=u>&#x2462;</span></a>
<samp class=pp>1247520344.9537716</samp>
<a><samp class=p>>>> </samp><kbd class=pp>import time</kbd>                        <span class=u>&#x2463;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>time.localtime(metadata.st_mtime)</kbd>  <span class=u>&#x2464;</span></a>
<samp class=pp>time.struct_time(tm_year=2009, tm_mon=7, tm_mday=13, tm_hour=17,
  tm_min=25, tm_sec=44, tm_wday=0, tm_yday=194, tm_isdst=1)</samp>
</pre>
<ol>
<li>Le répertoire de travail est le dossier <code>examples</code>.
<li><code>feed.xml</code> est un fichier du dossier <code>examples</code>. Appeler la fonction <code>os.stat()</code> retourne un objet qui contient différent types de méta-données à propos du fichier.
<li><code>st_mtime</code> est la date de dernière modification, mais dans un format qui n’est pas particulièrement utile. (Techniquement, c’est le nombre de secondes depuis Epoch, qui est défini comme la première seconde depuis le 1er janvier 1970. Sérieusement.)
<li>Le module <code>time</code> fait partie de la bibliothèque standard de Python. Il contient des fonctions pour convertir entre différentes représentations de temps, des formats de valeurs temporelles en chaines, et gérer les fuseau horaires.
<li>La fonction <code>time.localtime()</code> convertit une valeur temporelle de secondes-depuis-Epoch (à partir de la propriété <code>st_mtime</code> retournée par la fonction <code>os.stat()</code>) en une structure plus utile d’année, mois, jour, heure, minute, seconde, etc. Ce fichier a été modifié pour la dernière fois le 13 juillet 2009, vers 17h25.
</ol>

<pre class=screen>
# Poursuite de l’exemple précédent
<a><samp class=p>>>> </samp><kbd class=pp>metadata.st_size</kbd>                              <span class=u>&#x2460;</span></a>
<samp class=pp>3070</samp>
<samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>humansize.approximate_size(metadata.st_size)</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>'3.0 KiB'</samp></pre>
<ol>
<li>La fonction <code>os.stat()</code> retourne aussi la taille du fichier, dans la propriété <code>st_size</code>. Le fichier <code>feed.xml</code> fait <code>3070</code> octets.
<li>Vous pouvez passer la propriété <code>st_size</code> à la fonction <a href=your-first-python-program.html#divingin><code>approximate_size()</code></a>.
</ol>

<h3 id=abspath>Constructing Absolute Pathnames</h3>

<p>Dans <a href=#osstat>la section précédente</a>, la fonction <code>glob.glob()</code> retournait une liste de chemins relatifs. Le premier exemple avait des chemins tels que <code>'examples\feed.xml'</code>, et le second en avait des encore plus courts, tels que <code>'romantest1.py'</code>. Du moment que vous restez dans le même répertoire de travail, ces chemins relatifs fonctionneront pour ouvrir des fichiers ou accéder à leurs méta-données. Mais si vous voulez construire un chemin absolu&nbsp;&mdash;&nbsp;c’est-à-dire un qui inclut tous les noms de répertoires depuis la racine ou la lettre de lecteur&nbsp;&mdash;&nbsp;alors vous aurez besoin de la fonction <code>os.path.realpath()</code>.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os</kbd>
<samp class=p>>>> </samp><kbd class=pp>print(os.getcwd())</kbd>
<samp class=pp>c:\Users\pilgrim\diveintopython3\examples</samp>
<samp class=p>>>> </samp><kbd class=pp>print(os.path.realpath('feed.xml'))</kbd>
<samp class=pp>c:\Users\pilgrim\diveintopython3\examples\feed.xml</samp></pre>

<p class=a>&#x2042;

<h2 id=listcomprehension>List Comprehensions</h2>

<aside>You can use any Python expression in a list comprehension.</aside>

<p>A <dfn>list comprehension</dfn> provides a compact way of mapping a list into another list by applying a function to each of the elements of the list.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_list = [1, 9, 8, 4]</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>[elem * 2 for elem in a_list]</kbd>           <span class=u>&#x2460;</span></a>
<samp class=pp>[2, 18, 16, 8]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list</kbd>                                  <span class=u>&#x2461;</span></a>
<samp class=pp>[1, 9, 8, 4]</samp>
<a><samp class=p>>>> </samp><kbd class=pp>a_list = [elem * 2 for elem in a_list]</kbd>  <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp><kbd>a_list</kbd>
<samp class=pp>[2, 18, 16, 8]</samp></pre>
<ol>
<li>To make sense of this, look at it from right to left. <var>a_list</var> is the list you&#8217;re mapping. The Python interpreter loops through <var>a_list</var> one element at a time, temporarily assigning the value of each element to the variable <var>elem</var>. Python then applies the function <code><var>elem</var> * 2</code> and appends that result to the returned list.
<li>A list comprehension creates a new list; it does not change the original list.
<li>It is safe to assign the result of a list comprehension to the variable that you&#8217;re mapping. Python constructs the new list in memory, and when the list comprehension is complete, it assigns the result to the original variable.
</ol>

<p>You can use any Python expression in a list comprehension, including the functions in the <code>os</code> module for manipulating files and directories.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os, glob</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>glob.glob('*.xml')</kbd>                                 <span class=u>&#x2460;</span></a>
<samp class=pp>['feed-broken.xml', 'feed-ns0.xml', 'feed.xml']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>[os.path.realpath(f) for f in glob.glob('*.xml')]</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>['c:\\Users\\pilgrim\\diveintopython3\\examples\\feed-broken.xml',
 'c:\\Users\\pilgrim\\diveintopython3\\examples\\feed-ns0.xml',
 'c:\\Users\\pilgrim\\diveintopython3\\examples\\feed.xml']</samp>
</pre>
<ol>
<li>This returns a list of all the <code>.xml</code> files in the current working directory.
<li>This list comprehension takes that list of <code>.xml</code> files and transforms it into a list of full pathnames.
</ol>

<p>List comprehensions can also filter items, producing a result that can be smaller than the original list.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os, glob</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>[f for f in glob.glob('*.py') if os.stat(f).st_size > 6000]</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>['pluraltest6.py',
 'romantest10.py',
 'romantest6.py',
 'romantest7.py',
 'romantest8.py',
 'romantest9.py']</samp>
</pre>
<ol>
<li>To filter a list, you can include an <code>if</code> clause at the end of the list comprehension. The expression after the <code>if</code> keyword will be evaluated for each item in the list. If the expression evaluates to <code>True</code>, the item will be included in the output. This list comprehension looks at the list of all <code>.py</code> files in the current directory, and the <code>if</code> expression filters that list by testing whether the size of each file is greater than <code>6000</code> bytes. There are six such files, so the list comprehension returns a list of six filenames.
</ol>

<p>All the examples of list comprehensions so far have featured simple expressions&nbsp;&mdash;&nbsp;multiply a number by a constant, call a single function, or simply return the original list item (after filtering). But there&#8217;s no limit to how complex a list comprehension can be.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os, glob</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>[(os.stat(f).st_size, os.path.realpath(f)) for f in glob.glob('*.xml')]</kbd>            <span class=u>&#x2460;</span></a>
<samp class=pp>[(3074, 'c:\\Users\\pilgrim\\diveintopython3\\examples\\feed-broken.xml'),
 (3386, 'c:\\Users\\pilgrim\\diveintopython3\\examples\\feed-ns0.xml'),
 (3070, 'c:\\Users\\pilgrim\\diveintopython3\\examples\\feed.xml')]</samp>
<samp class=p>>>> </samp><kbd class=pp>import humansize</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>[(humansize.approximate_size(os.stat(f).st_size), f) for f in glob.glob('*.xml')]</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>[('3.0 KiB', 'feed-broken.xml'),
 ('3.3 KiB', 'feed-ns0.xml'),
 ('3.0 KiB', 'feed.xml')]</samp></pre>
<ol>
<li>This list comprehension finds all the <code>.xml</code> files in the current working directory, gets the size of each file (by calling the <code>os.stat()</code> function), and constructs a tuple of the file size and the absolute path of each file (by calling the <code>os.path.realpath()</code> function).
<li>This comprehension builds on the previous one to call the <a href=your-first-python-program.html#divingin><code>approximate_size()</code> function</a> with the file size of each <code>.xml</code> file.
</ol>

<p class=a>&#x2042;

<h2 id=dictionarycomprehension>Dictionary Comprehensions</h2>

<p>A <dfn>dictionary comprehension</dfn> is like a list comprehension, but it constructs a dictionary instead of a list.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os, glob</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>metadata = [(f, os.stat(f)) for f in glob.glob('*test*.py')]</kbd>    <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>metadata[0]</kbd>                                                     <span class=u>&#x2461;</span></a>
<samp class=pp>('alphameticstest.py', nt.stat_result(st_mode=33206, st_ino=0, st_dev=0,
 st_nlink=0, st_uid=0, st_gid=0, st_size=2509, st_atime=1247520344,
 st_mtime=1247520344, st_ctime=1247520344))</samp>
<a><samp class=p>>>> </samp><kbd class=pp>metadata_dict = {f:os.stat(f) for f in glob.glob('*test*.py')}</kbd>  <span class=u>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>type(metadata_dict)</kbd>                                             <span class=u>&#x2463;</span></a>
<samp>&lt;class 'dict'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>list(metadata_dict.keys())</kbd>                                      <span class=u>&#x2464;</span></a>
<samp class=pp>['romantest8.py', 'pluraltest1.py', 'pluraltest2.py', 'pluraltest5.py',
 'pluraltest6.py', 'romantest7.py', 'romantest10.py', 'romantest4.py',
 'romantest9.py', 'pluraltest3.py', 'romantest1.py', 'romantest2.py',
 'romantest3.py', 'romantest5.py', 'romantest6.py', 'alphameticstest.py',
 'pluraltest4.py']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>metadata_dict['alphameticstest.py'].st_size</kbd>                     <span class=u>&#x2465;</span></a>
<samp class=pp>2509</samp></pre>
<ol>
<li>This is not a dictionary comprehension; it&#8217;s a <a href=#listcomprehension>list comprehension</a>. It finds all <code>.py</code> files with <code>test</code> in their name, then constructs a tuple of the filename and the file metadata (from calling the <code>os.stat()</code> function).
<li>Each item of the resulting list is a tuple.
<li>This is a dictionary comprehension. The syntax is similar to a list comprehension, with two differences. First, it is enclosed in curly braces instead of square brackets. Second, instead of a single expression for each item, it contains two expressions separated by a colon. The expression before the colon (<code>f</code> in this example) is the dictionary key; the expression after the colon (<code>os.stat(f)</code> in this example) is the value.
<li>A dictionary comprehension returns a dictionary.
<li>The keys of this particular dictionary are simply the filenames returned from the call to <code>glob.glob('*test*.py')</code>.
<li>The value associated with each key is the return value from the <code>os.stat()</code> function. That means we can &#8220;look up&#8221; a file by name in this dictionary to get its file metadata. One of the pieces of metadata is <code>st_size</code>, the file size. The file <code>alphameticstest.py</code> is <code>2509</code> bytes long.
</ol>

<p>Like list comprehensions, you can include an <code>if</code> clause in a dictionary comprehension to filter the input sequence based on an expression which is evaluated with each item.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import os, glob, humansize</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>metadata_dict = {f:os.stat(f) for f in glob.glob('*')}</kbd>                                  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>humansize_dict = {os.path.splitext(f)[0]:humansize.approximate_size(meta.st_size) \     </kbd>
<samp class=p>... </samp><kbd class=pp>                  for f, meta in metadata_dict.items() if meta.st_size > 6000}</kbd>          <span class=u>&#x2461;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>list(humansize_dict.keys())</kbd>                                                             <span class=u>&#x2462;</span></a>
<samp class=pp>['romantest9', 'romantest8', 'romantest7', 'romantest6', 'romantest10', 'pluraltest6']</samp>
<a><samp class=p>>>> </samp><kbd class=pp>humansize_dict['romantest9']</kbd>                                                            <span class=u>&#x2463;</span></a>
<samp class=pp>'6.5 KiB'</samp></pre>
<ol>
<li>This dictionary comprehension constructs a list of all the files in the current working directory (<code>glob.glob('*')</code>), gets the file metadata for each file (<code>os.stat(f)</code>), and constructs a dictionary whose keys are filenames and whose values are the metadata for each file.
<li>This dictionary comprehension builds on the previous comprehension, filters out files smaller than <code>6000</code> bytes (<code>if meta.st_size > 6000</code>), and uses that filtered list to construct a dictionary whose keys are the filename minus the extension (<code>os.path.splitext(f)[0]</code>) and whose values are the approximate size of each file (<code>humansize.approximate_size(meta.st_size)</code>).
<li>As you saw in a previous example, there are six such files, thus there are six items in this dictionary.
<li>The value of each key is the string returned from the <code>approximate_size()</code> function.
</ol>

<h3 id=stupiddicttricks>Other Fun Stuff To Do With Dictionary Comprehensions</h3>

<p>Here&#8217;s a trick with dictionary comprehensions that might be useful someday: swapping the keys and values of a dictionary.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_dict = {'a': 1, 'b': 2, 'c': 3}</kbd>
<samp class=p>>>> </samp><kbd class=pp>{value:key for key, value in a_dict.items()}</kbd>
<samp class=pp>{1: 'a', 2: 'b', 3: 'c'}</samp></pre>

<p>Of course, this only works if the values of the dictionary are immutable, like strings or tuples. If you try this with a dictionary that contains lists, it will fail most spectacularly.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_dict = {'a': [1, 2, 3], 'b': 4, 'c': 5}</kbd>
<samp class=p>>>> </samp><kbd class=pp>{value:key for key, value in a_dict.items()}</kbd>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
  File "&lt;stdin>", line 1, in &lt;dictcomp>
TypeError: unhashable type: 'list'</samp></pre>

<p class=a>&#x2042;

<h2 id=setcomprehension>Set Comprehensions</h2>

<p>Not to be left out, sets have their own comprehension syntax as well. It is remarkably similar to the syntax for dictionary comprehensions. The only difference is that sets just have values instead of key:value pairs.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>a_set = set(range(10))</kbd>
<samp class=p>>>> </samp><kbd class=pp>a_set</kbd>
<samp class=pp>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>{x ** 2 for x in a_set}</kbd>           <span class=u>&#x2460;</span></a>
<samp class=pp>{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>{x for x in a_set if x % 2 == 0}</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>{0, 8, 2, 4, 6}</samp>
<a><samp class=p>>>> </samp><kbd class=pp>{2**x for x in range(10)}</kbd>         <span class=u>&#x2462;</span></a>
<samp class=pp>{32, 1, 2, 4, 8, 64, 128, 256, 16, 512}</samp>
</pre>
<ol>
<li>Set comprehensions can take a set as input. This set comprehension calculates the squares of the set of numbers from 0 to <code>9</code>.
<li>Like list comprehensions and dictionary comprehensions, set comprehensions can contain an <code>if</code> clause to filter each item before returning it in the result set.
<li>Set comprehensions do not need to take a set as input; they can take any sequence.
</ol>

<p class=a>&#x2042;

<h2 id=furtherreading>Further Reading</h2>
<ul>
<li><a href=http://docs.python.org/3.1/library/os.html><code>os</code> module</a>
<li><a href=http://www.doughellmann.com/PyMOTW/os/><code>os</code>&nbsp;&mdash;&nbsp;Portable access to operating system specific features</a>
<li><a href=http://docs.python.org/3.1/library/os.path.html><code>os.path</code> module</a>
<li><a href=http://www.doughellmann.com/PyMOTW/ospath/><code>os.path</code>&nbsp;&mdash;&nbsp;Platform-independent manipulation of file names</a>
<li><a href=http://docs.python.org/3.1/library/glob.html><code>glob</code> module</a>
<li><a href=http://www.doughellmann.com/PyMOTW/glob/><code>glob</code>&nbsp;&mdash;&nbsp;Filename pattern matching</a>
<li><a href=http://docs.python.org/3.1/library/time.html><code>time</code> module</a>
<li><a href=http://www.doughellmann.com/PyMOTW/time/><code>time</code>&nbsp;&mdash;&nbsp;Functions for manipulating clock time</a>
<li><a href=http://docs.python.org/3.1/tutorial/datastructures.html#list-comprehensions>List comprehensions</a>
<li><a href=http://docs.python.org/3.1/tutorial/datastructures.html#nested-list-comprehensions>Nested list comprehensions</a>
<li><a href=http://docs.python.org/3.1/tutorial/datastructures.html#looping-techniques>Looping techniques</a>
</ul>
<p class=v><a href=native-datatypes.html rel=prev title='back to &#8220;Native Datatypes&#8221;'><span class=u>&#x261C;</span></a> <a href=strings.html rel=next title='onward to &#8220;Strings&#8221;'><span class=u>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
