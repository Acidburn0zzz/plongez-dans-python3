---
title: Classes <i class=baa>&amp;</i> Itérateurs
status: En cours
permalink: iterators.html
---
<!DOCTYPE html>
<meta charset=utf-8>
<title>Classes &amp; Itérateurs - Plongez dans Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 7}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=sa value=Search></div></form>
<p>Vous êtes ici&nbsp;: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#iterators>Plongez dans Python 3</a> <span class=u>&#8227;</span>
<p id=level>Difficulty level: <span class=u title=intermediate>&#x2666;&#x2666;&#x2666;&#x2662;&#x2662;</span>
<h1>Classes <i class=baa>&amp;</i> Itérateurs</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> L’Orient et l’Occident&nbsp;: deux mondes qui jamais ne pourront se rejoindre <span class=u>&#x275E;</span><br>&mdash; <a href=http://en.wikiquote.org/wiki/Rudyard_Kipling>Rudyard Kipling</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Diving In</h2>
<p class=f>Les itérateurs sont la «&nbsp;sauce secrète&nbsp;» de Python 3. Ils sont partout, sous-jacents à tout, mais toujours hors de vue. <a href=comprehensions.html>Les compréhensions</a> sont juste une forme simple d’<i>itérateurs</i>. Les générateurs sont juste une forme simple d’<i>itérateurs</i>. Une fonction qui <code>yield</code> (NdT&nbsp;: https://fr.wikipedia.org/wiki/Yield_(instruction)) les valeurs est un moyen correct et compact de construire un itérateur sans construire d’itérateur. Laissez-moi vous montrer ce que je veux dire par là.

<p>Vous rappelez-vous <a href=generators.html#a-fibonacci-generator>le générateur Fibonacci</a>&nbsp;? Voici un itérateur écrit à partir de zéro&nbsp;:

<p class=d>[<a href=examples/fibonacci2.py>télécharger <code>fibonacci2.py</code></a>]
<pre class=pp><code>class Fib:
    '''iterator that yields numbers in the Fibonacci sequence'''

    def __init__(self, max):
        self.max = max

    def __iter__(self):
        self.a = 0
        self.b = 1
        return self

    def __next__(self):
        fib = self.a
        if fib > self.max:
            raise StopIteration
        self.a, self.b = self.b, self.a + self.b
        return fib</code></pre>

<p>Analysons ce code ligne par ligne.

<pre class='nd pp'><code>class Fib:</code></pre>

<p><code>class</code>? Qu’est-ce qu’une classe&nbsp;?

<p class=a>&#x2042;

<h2 id=defining-classes>Définition des Classes</h2>

<p>Python est entièrement orienté objet&nbsp;: vous pouvez définir vos propres classes, hériter de vos propres classes ou de classes intégrées, et instancier les classes que vous avez définies.

<p>Définir une classe en Python est simple. Comme les fonctions, il n’existe pas de définition spécifique de l’interface. Il suffit de définir la classe et de commencer à coder. Une classe Python commence par le mot réservé <code>class</code>, suivi du nom de la classe. Techniquement, c’est tout ce qui est nécessaire, car une classe n’a pas besoin d’hériter d’une autre classe.

<pre class=pp><code><a>class PapayaWhip:  <span class=u>&#x2460;</span></a>
<a>    pass           <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li> Le nom de cette classe est <code>PapayaWhip</code>, et elle n’hérite pas d’une autre classe. Les noms de classes sont habituellement capitalisés, <code>ChaqueMotCommeCeci</code>, mais ce n’est qu’une convention, pas une obligation.
<li>Vous l’aurez sans doute deviné, mais tout dans une classe est indenté, tout comme le code dans une fonction, bloc <code>if</code>, boucle <code>for</code>, ou tout autre bloc de code. La première ligne non indentée est en dehors de la classe.
</ ol>

<p><code>PapayaWhip</code> ne définit aucune méthode ni attribut, mais syntaxiquement, il doit y avoir quelque chose dans la définition, d’où l’utilisation de <code>pass</code>. Il s’agit d’un mot réservé de Python qui signifie simplement «&nbsp;Circulez, rien à voir ici.&nbsp;» C’est une déclaration qui ne fait rien, et c’est un bon marqueur lorsque vous écrivez un squelette de fonction ou de classe.

<blockquote class='note compare java'>
<p><span class=u>&#x261E;</span>La déclaration <code>pass</code> en Python est comme un ensemble vide d’accolades (<code>{}</code>) en Java ou C.
</blockquote>

<p> De nombreuses classes sont héritées d’autres classes, mais celle-ci ne l’est pas. De nombreuses classes définissent des méthodes, mais celle-ci ne le fait pas. Il n’y a rien qu’une classe Python doit absolument avoir en dehors d’un nom. En particulier, les programmeurs C++ s’étonneront sans doute que les classes Python n’aient pas de constructeurs et de destructeurs explicites. Bien qu’il ne soit pas obligatoire, les classes Python <em>peuvent</em> avoir quelque chose de semblable à un constructeur&nbsp;: la méthode <code>__init__()</code>.

<h3 id=init-method>La méthode <code>__init__()</code></h3>

<p>Cet exemple montre l’initialisation de la classe <code>Fib</code> avec la méthode <code>__init__</code>.

<pre class=pp><code>class Fib:
<a>    '''iterator that yields numbers in the Fibonacci sequence'''  <span class=u>&#x2460;</span></a>

<a>    def __init__(self, max):                                      <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li>Les classes peuvent (et devraient) aussi avoir une <code>docstring</code>, tout comme les modules et les fonctions.
<li>La méthode <code>__init__()</code> est appelée immédiatement après qu’une instance de la classe ait été créée. Il serait tentant&nbsp;&mdash;&nbsp;mais techniquement incorrect&nbsp;&mdash;&nbsp;de l’appeler le «&nbsp;constructeur&nbsp;» de la classe. Il est tentant, parce qu’il ressemble à un constructeur C++ (par convention, la méthode <code>__init__()</code> est la première méthode définie pour la classe), agit comme un constructeur (c’est le premier morceau de code exécuté lors de la création d’une nouvelle instance de la classe), et sonne pareil. Incorrect, car l’objet a déjà été construit au moment où le <code>__init__()</code> est appelé, et vous avez déjà une référence valide à la nouvelle instance de la classe.
</ol>

<p>Le premier argument de chaque méthode de la classe, y compris la méthode <code>__init__()</code>, est toujours une référence à l’instance actuelle de la classe. Par convention, cet argument est nommé <var>self</var>. Cet argument remplit le rôle du mot réservé <code>this</code> dans <abbr>C++</abbr> ou Java, mais <var>self</var> n’est pas un mot réservé de Python, seulement une convention de nommage. Cependant, veuillez ne pas l’appeler autrement que <var>self</var>&nbsp;: c’est une convention très forte.

<p>Dans toutes les méthodes de classe, <var>self</var> se réfère à l’instance dont la méthode a été appelée. Mais dans le cas spécifique de la méthode <code>__init__()</code>, l’instance dont la méthode a été appelée est également l’objet nouvellement créé. Bien que vous deviez spécifier <var>self</var> explicitement lorsque vous définissez la méthode, vous <em>n’</em>avez <em>pas</em> à le spécifier lorsque vous appelez la méthode&nbsp;: Python l’ajoutera automatiquement pour vous.

<p class=a>&#x2042;

<h2 id=instantiating-classes>Instantiation de Classes</h2>

<p> L’instanciation de classes en Python est simple. Pour instancier une classe, appelez simplement la classe comme si elle était une fonction, en passant les arguments que le <code>__init__()</code> a besoin. La valeur de retour sera l’objet nouvellement créé.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import fibonacci2</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>fib = fibonacci2.Fib(100)</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>fib</kbd>                        <span class=u>&#x2461;</span></a>
<samp class=pp>&lt;fibonacci2.Fib object at 0x00DB8810></samp>
<a><samp class=p>>>> </samp><kbd class=pp>fib.__class__</kbd>              <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;class 'fibonacci2.Fib'></samp>
<a><samp class=p>>>> </samp><kbd class=pp>fib.__doc__</kbd>                <span class=u>&#x2463;</span></a>
<samp class=pp>'iterator that yields numbers in the Fibonacci sequence'</samp></pre>
<ol>
<li>Vous créez une instance de la classe <code>Fib</code> (définie dans le module <code>fibonacci2</code>) et assignez l’instance nouvellement créée à la variable <var>fib</var>. Nous passons un paramètre, <code>100</code>, qui finira comme l’argument <var>max</var> dans la méthode <code>__init__()</code> de <code>Fib</code>.
<var>fib</var> est maintenant une instance de la classe <code>Fib</code>.
<li>Chaque instance de classe a un attribut prédéfini, <code>__class__</code>, qui est la classe de l’objet. Les programmeurs Java sont sans doute familiers de la classe <code>Class</code>, qui contient des méthodes comme <code>getName()</code> et <code>getSuperclass()</code> pour obtenir des informations de méta-données relatives à un objet. En Python, ce genre de méta-données est disponible par le biais des attributs, mais l’idée est la même.
Vous pouvez accéder l’instance <code>docstring</code> comme pour une fonction ou un module. Toutes les instances d’une classe partagent la même <code>docstring</code>.
</ol>

<blockquote class='note compare java'>
<p><span class=u>&#x261E;</span>En Python, appelez simplement une classe comme s’il s’agissait d’une fonction pour créer une nouvelle instance de la classe. Il n’y a pas d’opérateur explicite <code>new</code> comme dans <abbr>C++</abbr> ou Java.
</blockquote>

<p class=a>&#x2042;

<h2 id=instance-variables>Instancier des Variables</h2>

<p>Sur la ligne suivante&nbsp;:

<pre class=pp><code>class Fib:
    def __init__(self, max):
<a>        self.max = max        <span class=u>&#x2460;</span></a></code></pre>
<ol>
<li> Qu’est-ce que <var>self.max</var>&nbsp;? C’est une variable d’instance. Elle est complètement séparée de <var>max</var>, qui a été adopté dans le <code>__init__()</code> comme argument. <var>self.max</var> est «&nbsp;global&nbsp;» à l’instance. Cela signifie que vous pouvez y accéder à partir d’autres méthodes.
</ol>

<pre class=pp><code>class Fib:
    def __init__(self, max):
<a>        self.max = max        <span class=u>&#x2460;</span></a>
    .
    .
    .
    def __next__(self):
        fib = self.a
<a>        if fib > self.max:    <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li><var>self.max</var> est défini dans la méthode <code>__init__()</code>&hellip;
<li>&hellip;et référencé dans la méthode <code>__next__()</code>.
</ol>

<p>Les variables d’instance sont spécifiques à une instance d’une classe. Par exemple, si vous créez deux instances <code>Fib</code> avec des valeurs maximales différentes, ils se souviendront chacun de leurs propres valeurs.

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>import fibonacci2</kbd>
<samp class=p>>>> </samp><kbd class=pp>fib1 = fibonacci2.Fib(100)</kbd>
<samp class=p>>>> </samp><kbd class=pp>fib2 = fibonacci2.Fib(200)</kbd>
<samp class=p>>>> </samp><kbd class=pp>fib1.max</kbd>
<samp class=pp>100</samp>
<samp class=p>>>> </samp><kbd class=pp>fib2.max</kbd>
<samp class=pp>200</samp></pre>

<p class=a>&#x2042;

<h2 id=a-fibonacci-iterator>Un itérateur Fibonacci</h2>

<p><em>Maintenant</em> vous êtes prêt à apprendre à construire un itérateur. Un itérateur est simplement une classe qui définit un <code>__iter__()</code>.

<aside class=ots>
Chacune de ces trois méthodes de classe, <code>__init__</code>,<code>__iter__</code>, et <code>__next__</code>, commencent et finissent avec une paire de caractères underscore (<code>_</code>). Pourquoi&nbsp;? Il n’y a rien de magique, mais cela indique généralement que ce sont des «&nbsp;<dfn>méthodes spéciales</dfn>&nbsp;». La seule chose «&nbsp;spéciale&nbsp;» sur les méthodes spéciales, c’est qu’elles ne sont pas appelées directement&nbsp;: Python les appelle lorsque vous utilisez une autre syntaxe ou  instance de la classe. <a href=special-method-names.html>Davantage sur les méthodes spéciales</a>.
</aside>

<p class=d>[<a href=examples/fibonacci2.py>download <code>fibonacci2.py</code></a>]
<pre class=pp><code><a>class Fib:                    <span class=u>&#x2460;</span></a>
<a>    def __init__(self, max):                      <span class=u>&#x2461;</span></a>
        self.max = max

<a>    def __iter__(self):                           <span class=u>&#x2462;</span></a>
        self.a = 0
        self.b = 1
        return self

<a>    def __next__(self):                           <span class=u>&#x2463;</span></a>
        fib = self.a
        if fib > self.max:
<a>            raise StopIteration                   <span class=u>&#x2464;</span></a>
        self.a, self.b = self.b, self.a + self.b
<a>        return fib                                <span class=u>&#x2465;</span></a></code></pre>
<ol>
<li>Pour construire un itérateur à partir de zéro, <code>Fib</code> doit être une classe, pas une fonction.
<li>«&nbsp;Appeler&nbsp;» <code>Fib(max)</code> crée vraiment une instance de cette classe et appelle sa méthode <code>__init__()</code> avec <var>max</var>. La méthode <code>__init__()</code> enregistre la valeur maximale comme une variable d’instance afin que d’autres méthodes puissennt s’y référer plus tard.
<li>La méthode <code>__iter__()</code> est appelée chaque fois que quelqu’un appelle <code>iter(fib)</code>. (Comme vous le verrez dans une minute, une boucle <code>for</code> l’appellera automatiquement, mais vous pouvez également l’appeler vous-même manuellement). Après avoir effectué l’initialisation de début de l’itération (dans ce cas, la réinitialisation <code>self.a</code> et <code>self.b</code>, nos deux compteurs), la méthode <code>__iter__()</code> peut retourner n’importe quel objet qui implémente une méthode <code>__next__()</code>. Dans ce cas (et dans la plupart des cas), <code>__iter__()</code> renvoie simplement <var>self</var>, puisque cette classe implémente sa propre méthode <code>__next__()</code>.
<li>La méthode <code>__next__()</code> est appelée chaque fois que quelqu’un appelle <code>next()</code> sur un itérateur d’une instance d’une classe. Cela fera plus de sens dans une minute.
<li>Lorsque la méthode <code>__next__()</code> soulève une exception <code>StopIteration</code>, cela indique à l’appelant que l’itération est épuisée. Contrairement à la plupart des exceptions, ce n’est pas une erreur, c’est une condition normale qui signifie simplement que l’itérateur n’a plus de valeurs à générer. Si l’appelant est une boucle <code>for</code>, il saura remarqué cette exception <code>StopIteration</code> et sortir gracieusement de la boucle. (En d’autres termes, il va avaler l’exception.) Ce peu de magie est en fait la clé de l’utilisation des itérateurs dans des boucles <code>for</code>.
<li>Pour cracher la valeur suivante, une méthode <code>__next__()</code> de l’itérateur <code>retourne</code> simplement la valeur. N’utilisez pas <code>yield</code> ici, c’est un peu de sucre syntaxique qui s’applique uniquement lorsque vous utilisez les générateurs. Ici, vous créez votre propre itérateur à partir de zéro&nbsp;: utilisez plutôt <code>return</code>.
</ol>

<p>Pas encore perdu&nbsp;? Excellent. Voyons comment appeler cet itérateur&nbsp;:

<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>from fibonacci2 import Fib</kbd>
<samp class=p>>>> </samp><kbd class=pp>for n in Fib(1000):</kbd>
<samp class=p>... </samp><kbd class=pp>    print(n, end=' ')</kbd>
<samp class=pp>0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</samp></pre>

<p>Eh bien, c'est exactement la même chose&nbsp;! C’est identique octet par octet à la façon dont vous avez appelé <a href=generators.html#a-fibonacci-generator>Fibonacci-comme-un-générateur</a> (modulo une majuscule). Mais comment?

<p>Il y a un peu de magie impliquée dans les boucles <code>for</code>. Voici ce qui arrive&nbsp;:

<ul>
<li>La boucle <code>for</code> appelle <code>Fib(1000)</code>, comme indiqué. Ceci retourne une instance de la classe <code>Fib</code>. Appelons-la <var>fib_inst</var>.
<li>Secrètement, et assez habilement, la boucle <code>for</code> appelle <code>iter(fib_inst)</code>, qui renvoie un objet itérateur. Appelons-la <var>fib_iter</var>. Dans ce cas, <var>fib_iter</var> == <var>fib_inst</var>, parce que la méthode <code>__iter__()</code> retourne <var>self</var>, mais la boucle <code>for</code> ne sait rien (ou ne se préoccupe) à ce sujet.
<li>Pour «&nbsp;boucler à l’intérieur&nbsp;» de l’itérateur, la boucle <code>for</code> appelle <code>next(fib_iter)</code>, qui appelle la méthode <code>__next__()</code> sur l’objet <<code>fib_iter</code>, qui effectue les calculs du prochain nombre de Fibonacci et renvoie une valeur. La boucle <code>for</code> prend cette valeur, et l’assigne à <var>n</var>, puis exécute le corps de la boucle <code>for</code> pour cette valeur de <var>n</var>.
<li>Comment la boucle <code>for</code> sait quand s'arrêter&nbsp;? Je suis content que vous posiez la question&nbsp;! Quand <code>next(fib_iter)</code> soulève une exception <code>StopIteration</code>, la boucle <code>for</code> va avaler l’exception et se terminer normalement. (Toute autre exception va passer à travers et sera soulevée comme d'habitude.) Et où avez-vous vu une exception <code>StopIteration</code>&nbsp;? Dans la méthode <code>__next__()</code>, bien sûr&nbsp;!
</ul>

<p class=a>&#x2042;

<h2 id=a-plural-rule-iterator>A Plural Rule Iterator</h2>

<aside>iter(f) calls f.__iter__<br>next(f) calls f.__next__</aside>
<p>Now it&#8217;s time for the finale. Let&#8217;s rewrite the <a href=generators.html>plural rules generator</a> as an iterator.

<p class=d>[<a href=examples/plural6.py>télécharger <code>plural6.py</code></a>]
<pre class=pp><code>class LazyRules:
    rules_filename = 'plural6-rules.txt'

    def __init__(self):
        self.pattern_file = open(self.rules_filename, encoding='utf-8')
        self.cache = []

    def __iter__(self):
        self.cache_index = 0
        return self

    def __next__(self):
        self.cache_index += 1
        if len(self.cache) >= self.cache_index:
            return self.cache[self.cache_index - 1]

        if self.pattern_file.closed:
            raise StopIteration

        line = self.pattern_file.readline()
        if not line:
            self.pattern_file.close()
            raise StopIteration

        pattern, search, replace = line.split(None, 3)
        funcs = build_match_and_apply_functions(
            pattern, search, replace)
        self.cache.append(funcs)
        return funcs

rules = LazyRules()</code></pre>

<p>So this is a class that implements <code>__iter__()</code> and <code>__next__()</code>, so it can be used as an iterator. Then, you instantiate the class and assign it to <var>rules</var>. This happens just once, on import.

<p>Let&#8217;s take the class one bite at a time.

<pre class=pp><code>class LazyRules:
    rules_filename = 'plural6-rules.txt'

    def __init__(self):
<a>        self.pattern_file = open(self.rules_filename, encoding='utf-8')  <span class=u>&#x2460;</span></a>
<a>        self.cache = []                                                  <span class=u>&#x2461;</span></a></code></pre>
<ol>
<li>When we instantiate the <code>LazyRules</code> class, open the pattern file but don&#8217;t read anything from it. (That comes later.)
<li>After opening the patterns file, initialize the cache. You&#8217;ll use this cache later (in the <code>__next__()</code> method) as you read lines from the pattern file.
</ol>

<p>Before we continue, let&#8217;s take a closer look at <var>rules_filename</var>. It&#8217;s not defined within the <code>__iter__()</code> method. In fact, it&#8217;s not defined within <em>any</em> method. It&#8217;s defined at the class level. It&#8217;s a <i>class variable</i>, and although you can access it just like an instance variable (<var>self.rules_filename</var>), it is shared across all instances of the <code>LazyRules</code> class.

<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import plural6</kbd>
<samp class=p>>>> </samp><kbd class=pp>r1 = plural6.LazyRules()</kbd>
<samp class=p>>>> </samp><kbd class=pp>r2 = plural6.LazyRules()</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>r1.rules_filename</kbd>                               <span class=u>&#x2460;</span></a>
<samp class=pp>'plural6-rules.txt'</samp>
<samp class=p>>>> </samp><kbd class=pp>r2.rules_filename</kbd>
<samp class=pp>'plural6-rules.txt'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>r2.rules_filename = 'r2-override.txt'</kbd>           <span class=u>&#x2461;</span></a>
<samp class=p>>>> </samp><kbd class=pp>r2.rules_filename</kbd>
<samp class=pp>'r2-override.txt'</samp>
<samp class=p>>>> </samp><kbd class=pp>r1.rules_filename</kbd>
<samp class=pp>'plural6-rules.txt'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>r2.__class__.rules_filename</kbd>                     <span class=u>&#x2462;</span></a>
<samp class=pp>'plural6-rules.txt'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>r2.__class__.rules_filename = 'papayawhip.txt'</kbd>  <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp><kbd class=pp>r1.rules_filename</kbd>
<samp class=pp>'papayawhip.txt'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>r2.rules_filename</kbd>                               <span class=u>&#x2464;</span></a>
<samp class=pp>'r2-overridetxt'</samp></pre>
<ol>
<li>Each instance of the class inherits the <var>rules_filename</var> attribute with the value defined by the class.
<li>Changing the attribute&#8217;s value in one instance does not affect other instances&hellip;
<li>&hellip;nor does it change the class attribute. You can access the class attribute (as opposed to an individual instance&#8217;s attribute) by using the special <code>__class__</code> attribute to access the class itself.
<li>If you change the class attribute, all instances that are still inheriting that value (like <var>r1</var> here) will be affected.
<li>Instances that have overridden that attribute (like <var>r2</var> here) will not be affected.
</ol>

<p>And now back to our show.

<pre class=pp><code><a>    def __iter__(self):       <span class=u>&#x2460;</span></a>
        self.cache_index = 0
<a>        return self           <span class=u>&#x2461;</span></a>
</code></pre>
<ol>
<li>The <code>__iter__()</code> method will be called every time someone&nbsp;&mdash;&nbsp;say, a <code>for</code> loop&nbsp;&mdash;&nbsp;calls <code>iter(rules)</code>.
<li>The one thing that every <code>__iter__()</code> method must do is return an iterator. In this case, it returns <var>self</var>, which signals that this class defines a <code>__next__()</code> method which will take care of returning values throughout the iteration.
</ol>

<pre class=pp><code><a>    def __next__(self):                                 <span class=u>&#x2460;</span></a>
        .
        .
        .
        pattern, search, replace = line.split(None, 3)
<a>        funcs = build_match_and_apply_functions(        <span class=u>&#x2461;</span></a>
            pattern, search, replace)
<a>        self.cache.append(funcs)                        <span class=u>&#x2462;</span></a>
        return funcs</code></pre>
<ol>
<li>The <code>__next__()</code> method gets called whenever someone&nbsp;&mdash;&nbsp;say, a <code>for</code> loop&nbsp;&mdash;&nbsp;calls <code>next(rules)</code>. This method will only make sense if we start at the end and work backwards. So let&#8217;s do that.
<li>The last part of this function should look familiar, at least. The <code>build_match_and_apply_functions()</code> function hasn&#8217;t changed; it&#8217;s the same as it ever was.
<li>The only difference is that, before returning the match and apply functions (which are stored in the tuple <var>funcs</var>), we&#8217;re going to save them in <code>self.cache</code>.
</ol>

<p>Moving backwards&hellip;

<pre class=pp><code>    def __next__(self):
        .
        .
        .
<a>        line = self.pattern_file.readline()  <span class=u>&#x2460;</span></a>
<a>        if not line:                         <span class=u>&#x2461;</span></a>
            self.pattern_file.close()
<a>            raise StopIteration              <span class=u>&#x2462;</span></a>
        .
        .
        .</code></pre>
<ol>
<li>A bit of advanced file trickery here. The <code>readline()</code> method (note: singular, not the plural <code>readlines()</code>) reads exactly one line from an open file. Specifically, the next line. (<em>File objects are iterators too! It&#8217;s iterators all the way down&hellip;</em>)
<li>If there was a line for <code>readline()</code> to read, <var>line</var> will not be an empty string. Even if the file contained a blank line, <var>line</var> would end up as the one-character string <code>'\n'</code> (a carriage return). If <var>line</var> is really an empty string, that means there are no more lines to read from the file.
<li>When we reach the end of the file, we should close the file and raise the magic <code>StopIteration</code> exception. Remember, we got to this point because we needed a match and apply function for the next rule. The next rule comes from the next line of the file&hellip; but there is no next line! Therefore, we have no value to return. The iteration is over. (<span class=u>&#x266B;</span> The party&#8217;s over&hellip; <span class=u>&#x266B;</span>)
</ol>

<p>Moving backwards all the way to the start of the <code>__next__()</code> method&hellip;

<pre class=pp><code>    def __next__(self):
        self.cache_index += 1
        if len(self.cache) >= self.cache_index:
<a>            return self.cache[self.cache_index - 1]     <span class=u>&#x2460;</span></a>

        if self.pattern_file.closed:
<a>            raise StopIteration                         <span class=u>&#x2461;</span></a>
        .
        .
        .</code></pre>
<ol>
<li><code>self.cache</code> will be a list of the functions we need to match and apply individual rules. (At least <em>that</em> should sound familiar!) <code>self.cache_index</code> keeps track of which cached item we should return next. If we haven&#8217;t exhausted the cache yet (<i>i.e.</i> if the length of <code>self.cache</code> is greater than <code>self.cache_index</code>), then we have a cache hit! Hooray! We can return the match and apply functions from the cache instead of building them from scratch.
<li>On the other hand, if we don&#8217;t get a hit from the cache, <em>and</em> the file object has been closed (which could happen, further down the method, as you saw in the previous code snippet), then there&#8217;s nothing more we can do. If the file is closed, it means we&#8217;ve exhausted it&nbsp;&mdash;&nbsp;we&#8217;ve already read through every line from the pattern file, and we&#8217;ve already built and cached the match and apply functions for each pattern. The file is exhausted; the cache is exhausted; I&#8217;m exhausted. Wait, what? Hang in there, we&#8217;re almost done.
</ol>

<p>Putting it all together, here&#8217;s what happens when:

<ul>
<li>When the module is imported, it creates a single instance of the <code>LazyRules</code> class, called <var>rules</var>, which opens the pattern file but does not read from it.
<li>When asked for the first match and apply function, it checks its cache but finds the cache is empty. So it reads a single line from the pattern file, builds the match and apply functions from those patterns, and caches them.
<li>Let&#8217;s say, for the sake of argument, that the very first rule matched. If so, no further match and apply functions are built, and no further lines are read from the pattern file.
<li>Furthermore, for the sake of argument, suppose that the caller calls the <code>plural()</code> function <em>again</em> to pluralize a different word. The <code>for</code> loop in the <code>plural()</code> function will call <code>iter(rules)</code>, which will reset the cache index but will not reset the open file object.
<li>The first time through, the <code>for</code> loop will ask for a value from <var>rules</var>, which will invoke its <code>__next__()</code> method. This time, however, the cache is primed with a single pair of match and apply functions, corresponding to the patterns in the first line of the pattern file. Since they were built and cached in the course of pluralizing the previous word, they&#8217;re retrieved from the cache. The cache index increments, and the open file is never touched.
<li>Let&#8217;s say, for the sake of argument, that the first rule does <em>not</em> match this time around. So the <code>for</code> loop comes around again and asks for another value from <var>rules</var>. This invokes the <code>__next__()</code> method a second time. This time, the cache is exhausted&nbsp;&mdash;&nbsp;it only contained one item, and we&#8217;re asking for a second&nbsp;&mdash;&nbsp;so the <code>__next__()</code> method continues. It reads another line from the open file, builds match and apply functions out of the patterns, and caches them.
<li>This read-build-and-cache process will continue as long as the rules being read from the pattern file don&#8217;t match the word we&#8217;re trying to pluralize. If we do find a matching rule before the end of the file, we simply use it and stop, with the file still open. The file pointer will stay wherever we stopped reading, waiting for the next <code>readline()</code> command. In the meantime, the cache now has more items in it, and if we start all over again trying to pluralize a new word, each of those items in the cache will be tried before reading the next line from the pattern file.
</ul>

<p>We have achieved pluralization nirvana.

<ol>
<li><strong>Minimal startup cost.</strong> The only thing that happens on <code>import</code> is instantiating a single class and opening a file (but not reading from it).
<li><strong>Maximum performance.</strong> The previous example would read through the file and build functions dynamically every time you wanted to pluralize a word. This version will cache functions as soon as they&#8217;re built, and in the worst case, it will only read through the pattern file once, no matter how many words you pluralize.
<li><strong>Separation of code and data.</strong> All the patterns are stored in a separate file. Code is code, and data is data, and never the twain shall meet.
</ol>

<blockquote class=note>
<p><span class=u>&#x261E;</span>Is this really nirvana? Well, yes and no. Here&#8217;s something to consider with the <code>LazyRules</code> example: the pattern file is opened (during <code>__init__()</code>), and it remains open until the final rule is reached. Python will eventually close the file when it exits, or after the last instantiation of the <code>LazyRules</code> class is destroyed, but still, that could be a <em>long</em> time. If this class is part of a long-running Python process, the Python interpreter may never exit, and the <code>LazyRules</code> object may never get destroyed.
<p>There are ways around this. Instead of opening the file during <code>__init__()</code> and leaving it open while you read rules one line at a time, you could open the file, read all the rules, and immediately close the file. Or you could open the file, read one rule, save the file position with the <a href=files.html#read><code>tell()</code> method</a>, close the file, and later re-open it and use the <a href=files.html#read><code>seek()</code> method</a> to continue reading where you left off. Or you could not worry about it and just leave the file open, like this example code does. Programming is design, and design is all about trade-offs and constraints. Leaving a file open too long might be a problem; making your code more complicated might be a problem. Which one is the bigger problem depends on your development team, your application, and your runtime environment.
</blockquote>

<p class=a>&#x2042;

<h2 id=furtherreading>Further Reading</h2>
<ul>
<li><a href=http://docs.python.org/3.1/library/stdtypes.html#iterator-types>Iterator types</a>
<li><a href=http://www.python.org/dev/peps/pep-0234/>PEP 234: Iterators</a>
<li><a href=http://www.python.org/dev/peps/pep-0255/>PEP 255: Simple Generators</a>
<li><a href=http://www.dabeaz.com/generators/>Generator Tricks for Systems Programmers</a>
</ul>

<p class=v><a href=generators.html rel=prev title='back to &#8220;Closures &amp; Generators&#8221;'><span class=u>&#x261C;</span></a> <a href=advanced-iterators.html rel=next title='onward to &#8220;Advanced Iterators&#8221;'><span class=u>&#x261E;</span></a>

<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
