---
title: Expressions régulières
status: En cours
permalink: regular-expressions.html
---
<!DOCTYPE html>
<meta charset=utf-8>
<title>Expressions régulières - Plongez dans Python 3</title>
<!--[if IE]><script src=j/html5.js></script><![endif]-->
<link rel=stylesheet href=dip3.css>
<style>
body{counter-reset:h1 5}
</style>
<link rel=stylesheet media='only screen and (max-device-width: 480px)' href=mobile.css>
<link rel=stylesheet media=print href=print.css>
<meta name=viewport content='initial-scale=1.0'>
<form action=http://www.google.com/cse><div><input type=hidden name=cx value=014021643941856155761:l5eihuescdw><input type=hidden name=ie value=UTF-8>&nbsp;<input type=search name=q size=25 placeholder="powered by Google&trade;">&nbsp;<input type=submit name=root value=Search></div></form>
<p>You are here: <a href=index.html>Home</a> <span class=u>&#8227;</span> <a href=table-of-contents.html#regular-expressions>Plongez dans Python 3</a> <span class=u>&#8227;</span>
<p id=level>Niveau de difficulté : <span class=u title=intermediate>&#x2666;&#x2666;&#x2666;&#x2662;&#x2662;</span>
<h1>Expressions Rationnelles</h1>
<blockquote class=q>
<p><span class=u>&#x275D;</span> Certaines personnes, lorsqu’elles ont un problème, pensent «&nbsp;Je sais, je vais utiliser des expressions rationnelles.&nbsp;» − Maintenant elles ont deux problèmes. <span class=u>&#x275E;</span><br>&mdash; <a href=http://www.jwz.org/hacks/marginal.html>Jamie Zawinski</a>
</blockquote>
<p id=toc>&nbsp;
<h2 id=divingin>Plongée</h2>
<p class=f>Récupérer un petit bout de texte d’un gros bloc de texte peut relever de l’exploit. En Python, les chaines ont des méthodes pour rechercher et remplacer&nbsp;: <code>index()</code>, <code>find()</code>, <code>split()</code>, <code>count()</code>, <code>replace()</code>, etc. Mais ces méthodes sont limitées aux cas les plus simples. Par exemple, la méthode <code>index()</code> recherche une unique chaine prédéfinie, et la recherche est toujours sensible à la casse. Pour faire une recherche insensible à la casse d’une chaine <var>s</var>, vous devez appeler <code>s.lower()</code> ou <code>s.upper()</code> et vous assurer que les chaines recherchées sont dans la casse appropriée. Les méthodes <code>replace()</code> et <code>split()</code> ont les mêmes limitations.
<p>Si votre but peut être accompli avec les méthodes de chaine, vous devriez les utiliser. Elles sont rapides, simples, et faciles à lire&nbsp;; et il y a beaucoup d’arguments en faveur d’un code rapide, simple et lisible. Mais si vous vous trouvez dans un cas où vous devez utiliser beaucoup de méthodes de chaines avec des instructions <if> pour gérer les cas particuliers, ou si vous enchainez les appels à <code>split()</code> et <code>join()</code> pour séparer et recoller vos chaines, vous pourriez avoir besoin d’expressions régulières.
<p>Les expressions rationnelles sont une façon puissante et (plutôt) standard de rechercher, remplacer, et parser du texte avec des schémas de caractères complexes. Même si la syntaxe des expressions régulières est rigoureuse et diffère du code normal, le résultat peut être au final <em>plus</em> lisible qu’une solution faite soi-même utilisant une longue série de fonctions de chaine. Il y a même moyen d’inclure des commentaires dans les expressions rationnelles, donc vous pouvez y inclure une documentation fine.
<blockquote class='note compare perl5'
<p><span class=u>&#x261E;</span>Si vous avez déjà utilisé des expressions dans d’autre langages (comme Perl, Javascript, ou PHP), la syntaxe de Python vous semblera très familiaire. Lisez le sommaire du <a href=http://docs.python.org/dev/library/re.html#module-contents>module <code>re</code></a> pour avoir un aperçu des fonctions disponibles et de leurs paramètres.
</blockquote>
<p class=a>&#x2042;

<h2 id=streetaddresses>Étude De Cas&nbsp;: Adresses Postales</h2>
<p>Cette série d’exemple est inspirée d’un problème réel que j’ai eu à mon travail il y a quelques années, alors que je devais parcourir et standardiser des adresses postales d’un ancien système avant de les importer dans un nouveau. (Vous voyez, je n’invente pas tout&nbsp;: c’est vraiment utile.) Cet exemple montre comment j’ai approché le problème.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>s = '100 NORTH MAIN ROAD'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>s.replace('ROAD', 'RD.')</kbd>                <span class=u>&#x2460;</span></a>
<samp class=pp>'100 NORTH MAIN RD.'</samp>
<samp class=p>>>> </samp><kbd class=pp>s = '100 NORTH BROAD ROAD'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>s.replace('ROAD', 'RD.')</kbd>                <span class=u>&#x2461;</span></a>
<samp class=pp>'100 NORTH BRD. RD.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>s[:-4] + s[-4:].replace('ROAD', 'RD.')</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>'100 NORTH BROAD RD.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>import re</kbd>                               <span class=u>&#x2463;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('ROAD$', 'RD.', s)</kbd>               <span class=u>&#x2464;</span></a>
<samp class=pp>'100 NORTH BROAD RD.'</samp></pre>
<ol>
<li>Mon but est de standardiser l’adresse de façon à ce que <code>'ROAD'</code> soit toujours abrégé par <code>'RD.'</code>. À première vue, j'ai pensé que ce serait assez simple d’utiliser la méthode de chaine <code>replace()</code>. Après tout, toutes les données sont déjà en majuscules, dont les cas où ça ne correspond pas ne sont pas un problème. Et la chaine cherchée, <code>'ROAD'</code>, est une constante. Et dans cet exemple dramatiquement simple, <code>s.replace()</code> fonctionne effectivement.
<li>La vie est malheureusmeent pleine de contrexemples. Le problème ici est que <code>'ROAD'</code> apparait deux fois dans l’adresse, d’abord dans le nom de la rue, <code>'BROAD'</code> puis en tant que mot en lui-même. La méthode <code>replace()</code> voit ces deux occurences et remplace aveuglément les deux. Pendant ce temps, je vois mes adresses se faire détruire.
<li>Pour résoudre ce problème avec les adresses qui ont plus d’une sous-chaine <code>'ROAD'</code>, vous pouvez faire quelque chose comme ne remplacer <code>'ROAD'</code> que dans les quatre derniers caractères de l’adresse (<code>s[-4:]</code>), et laisser le reste tel quel (<code>s[:-4]</code>). Mais vous pouvez constater que ça commence à devenir assez lourd. Par exemple, le schéma est dépendant de la longueur de la chaine que vous voulez remplacer. (Si vous voulez remplacer <code>'STREET'</code> par <code>'ST.'</coee>, vous devrez utiliser à la place <code>s[:-6]</code> et <code>s[-6:].replace(...)</code>.) Voulez-vous revenir six mois plus tard et déboguer cela&nbsp;? Je sais que ce n’est pas mon cas.
<li>Il est temps de passer aux expressions rationnelles. En Python, toutes les fonctionnalités liées aux expressions rationelles sont contenues dans le module <code>re</code>.
<li>Jetez un coup d’œil au premier paramètre&nbsp;: <code>'ROAD$'</code>. C’est une expression rationnelle simple qui détecte <code>'ROAD'</code> seulement lorsqu’il est à la fin d’une chaine. Le <code>$</code> signifie «&nbsp;fin de la chaine&nbsp;» (Il y a un caractère correspondant, le chapeau <code>^</code>, qui signifie «&nbsp;début de la chaine&nbsp;».) En utilisant la fonction <code>re.sub()</code> vous recherchez l’expression rationelle <code>'ROAD$'</code> dans la chaine <code>s</code> et la remplacez avec <code>'RD.'</code>. Ceci détecte <code>ROAD</code> à la fin de la chaine <var>s</var>, mais <em>pas</em> le <code>ROAD</code> qui fait partie du mot <code>BROAD</code>, car il est au milieu de <var>s</var>.
</ol>
<aside>^ correspond au début d’une chaine. $ correspond à la fin d’une chaine.</aside>
<p>Pour continuer avec mon histoire de parcourir des adresses, j’ai vite découvert que limiter la détection de <code>'ROAD'</code> à la fin de l’adresse n’était pas suffisant, car toutes les adresses n’incluent pas du tout de désignation de rue. Certaines adresses se terminent simplement par le nom de la rue. Je m’en suis sorti la plupart du temps, mais lorsque la nom de la rue était <code>'BROAD'</code>, l’expression rationnelle aurait détecté <code>'ROAD'</code> à la fin de la chaine en temps que partie du mot <code>'BROAD'</code>, ce qui n’est pas ce que je voulais.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>s = '100 BROAD'</kbd>
<samp class=p>>>> </samp><kbd class=pp>re.sub('ROAD$', 'RD.', s)</kbd>
<samp class=pp>'100 BRD.'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub('\\bROAD$', 'RD.', s)</kbd>   <span class=u>&#x2460;</span></a>
<samp class=pp>'100 BROAD'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub(r'\bROAD$', 'RD.', s)</kbd>   <span class=u>&#x2461;</span></a>
<samp class=pp>'100 BROAD'</samp>
<samp class=p>>>> </samp><kbd class=pp>s = '100 BROAD ROAD APT. 3'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub(r'\bROAD$', 'RD.', s)</kbd>   <span class=u>&#x2462;</span></a>
<samp class=pp>'100 BROAD ROAD APT. 3'</samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.sub(r'\bROAD\b', 'RD.', s)</kbd>  <span class=u>&#x2463;</span></a>
<samp class=pp>'100 BROAD RD. APT 3'</samp></pre>
<ol>
<li>Ce que je veux <em>vraiment</em>, c’est détecter <code>'ROAD'</code> quand il est à la fin d’une chaine <em>et</em> qu’il ne fait pas partie d’un autre mot. Pour exprimer cela dans une expression rationnelle, vous utilisez <code>\b</code>, qui signifie «&nbsp;une frontière de mot doit être ici&nbsp;». En Python, ceci est complexe parce que le caractère <code>'/'</code> de la chaine lui-même doit être échappé. On appelle souvent ça le fléau du backslash, et c’est une des raisons pour laquelle les expressions rationnelles sont plus faciles en Perl qu’en Python. En même temps, Perl mélange expressions rationnelles avec la syntaxe classique, donc si vous avez un bogue, c’est plus difficile de dire s’il vient de la syntaxe ou de l’expression rationnelle.
<li>Pour contourner le fléau du backslash, vous pouvez utiliser ce qui est appelé une <i>chaine brute</i>, en préfixant la chaine avec la lettre <code>r</code>. Ceci dit à Python que rien dans cette chaine ne doit être échappé&nbsp;; <code>'\t'</code> est un caractère de tabulaton, mais <code>r'\t'</code> est vraiment le caractère backslash <code>\</code> suivi de la lettre <code>t</code>. Je recommande toujours d’utiliser des chaines brutes lorsque vous utilisez des expressions rationnelles&nbsp;; sinon les choses peuvent devenir confuses très vite (et les expressions rationnelles le sont déjà suffisament).
<li><em>*pfiou*</em>  Malheureusement, j’ai vite trouvé d’autres cas qui contredisaient ma logique. Dans ce cas, l’adresse contient le mot <code>'ROAD'</code> seul, mais il n’est pas à la fin, car l’adresse a un numéro d’appartement juste après la désignation de la rue. Parce que <code>'ROAD'</code> n’est pas exactement à la fin de la chaine, il n’est pas détecté, donc tout l’appel à <code>re.sub()</code> est inutile et vous récupérez la chaine de départ, ce qui n’est pas ce que vous voulez.
<li>Pour résoudre ce problème, j’ai supprimé le caractère <code>$</code> et j’ai ajouté un autre <code>\b</code>. Maintenant l’expression rationnelle «&nbsp;détecte <code>'ROAD'</code> lorsqu’il est en tant que mot à part entière&nbsp;», que ce soit à la fin, au début, ou quelque part au milieu.
</ol>
<p class=a>&#x2042;

<h2 id=romannumerals>Étude De Cas&nbsp;: Les Nombres Romains</h2>
<p>Vous avez probablement déjà vu des nombres romains, même si vous ne les avez pas reconnus. Vous avez pu les voir dans des droits d’auteurs de vieux films et séries («&nbsp;Copyright <code>MCMXLVI</code>&nbsp;» au lieu de «&nbsp;Copyright <code>1946</code>&nbsp;»), ou sur les monuments muraux de bibliothèques ou d’universités («&nbsp;established <code>MDCCCLXXXVIII</code>&nbsp;» au lieu de «&nbsp;established <code>1888</code>&nbsp;»). Vous pouvez aussi les avoir dans des titres ou des références bibliographiques. C’est un système représentant des nombres qui datent de l’ancien empire romain (d’où le nom).
<p>Dans la numérotation romaine, il y a sept caractères qui sont répétés et combinés de différentes façons pour représenter les nombres.
<ul>
<li><code>I = 1</code>
<li><code>V = 5</code>
<li><code>X = 10</code>
<li><code>L = 50</code>
<li><code>C = 100</code>
<li><code>D = 500</code>
<li><code>M = 1000</code>
</ul>
<p>Voici les différentes règles pour construire des nombres romains&nbsp;:
<ul>
<li>Parfois les caractères sont additifs. <code>I</code> est <code>1</code>, <code>II</code> est <code>2</code>, et <code>III</code> est <code>3</code>. <code>VI</code> est <code>6</code> (littéralement, «&nbsp;<code>5</code> et <code>1</code>&nbsp;»), <code>VII</code> est <code>7</code>, et <code>VIII</code> est <code>8</code>.
<li>Les caractères de dizaines (<code>I</code>, <code>X</code>, <code>C</code>, et <code>M</code>) peuvent être répétés jusqu’à trois fois. À partir de <code>4</code>, vous devez soustraire du caractère en cinq suivant. Vous ne pouvez représenter <code>4</code> par <code>IIII</code>&nbsp;; à la place, il est représenté par <code>IV</code> («&nbsp;<code>1</code> soustrait de <code>5</code>&nbsp;»). <code>40</code> est écrit <code>XL</code> («&nbsp;<code>10</code> soustrait de <code>50</code>&nbsp;»), <code>41</code> par <code>XLI</code>, <code>42</code> par <code>XLII</code>, <code>43</code> par <code>XLIII</code>, et enfin <code>44</code> par <code>XLIV</code> («&nbsp;<code>10</code> soustrait de <code>50</code>, plus <code>1</code> retiré de <code>5</code>&nbsp;»).
<li>Parfois les caractères sont&hellip; l’opposé d’être additifs. En ajoutant certains caractères avant d’autre, vous pouvez soustraire de la valeur finale. Par exemple, pour <code>9</code>, vous devez soustraire du caractère de dizaines suivant&nbsp;: <code>8</code> est <code>VIII</code>, mais <code>9</code> est <code>IX</code> («&nbsp;<code>1</code> retiré de <code>10</code>&nbsp;»), et non pas <code>VIIII</code> (puisque le caractère <code>I</code> ne peut être répété quatre fois). <code>90</code> est <code>XC</code>, <code>900</code> est <code>CM</code>.
<li>Les caractères en cinq ne peuvent être répétés. <code>10</code> est toujours représenté par <code>X</code>, jamais par <code>VV</code>. <code>100</code> est toujours <code>C</code>, jamais <code>LL</code>.
<li>Les nombres reomains sont lus de gauche à droite, donc l’ordre des caractères est très important. <code>DC</code> est <code>600</code>&nbsp;; <code>CD</code> est un nombre complètement différent (<code>400</code>, «&nbsp;<code>100</code> retiré de <code>500</code>&nbsp;»). <code>CI</code> est <code>101</code>&nbsp;; <code>IC</code> n’est même pas un nombre romain valide (car vous ne pouvez retirer directement <code>1</code> de <code>100</code>&nbsp;; vous devez l’écrire <code>XCIX</code>, «&nbsp;<code>10</code> retiré de <code>100</code>, plus <code>1</code> retiré de <code>10</code>&#8221;).
</ul>
<h3 id=thousands>Vérifier Les Milliers</h3>
<p>De quoi aurions-nous besoin pour vérifier qu’une chaine quelconque est un nombre romain valide&nbsp;? Prenons les chiffres un par un. Étant donné que les Romains écrivaient du plus grand au plus petit, commençons par le plus grand : les milliers. Pour les nombres supérieurs ou égaux ) 1000, les milliers étaient représentés par une série de caractères <code>M</code>.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?$'</kbd>        <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M')</kbd>     <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106FB58></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MM')</kbd>    <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106C290></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMM')</kbd>   <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106AA38></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMM')</kbd>  <span class=u>&#x2464;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, '')</kbd>      <span class=u>&#x2465;</span></a>
<samp>&lt;_sre.SRE_Match object at 0106F4A8></samp></pre>
<ol>
<li>Ce schéma a trois parties. <code>^</code> qui correspond au début de la chaine. S’il n’est pas spécifié, le schéma validerait quel que soit l’endroit où les caractères <code>M</code> se trouvent, ce qui n’est pas ce que vous voulez. Ce que vous voulez, c’est que, s’il y a des caractères <code>M</code>, ils soient au début de la chaine. <code>M?</code> détecte <em>au plus</em> un caractère <code>M</code>. Étant donné qu’il est répété trois fois, vous pouvez avoir entre zéro et trois caractères <code>M</code> de suite. Et <code>$</code> correspond à la fin de la chaine. Combiné au caractère <code>^</code>, cela signifique que le schéma doit correspondre à toute la chaine, sans caractère avant ou après les caractères <code>M</code>.
<li>L’essence-même du module <code>re</code> est la fonction <code>search()</code>, qui prend une expression réculière (<var>pattern</var>) et une chaine (<code>'M'</code>) à faire correspondre à lùexpression rationnelle. Si une correspondance existe, <code>search()</code> retourne un objet qui a différentes méthodes pour décrire la correspondance&nbsp;; et si aucune correspondance n’est trouvée, <code>search()</code> retourne <code>None</code>, la valeur nulle de Python. Pour l’instant nous ne nous occupons que de savoir si le schéma correspond, ce qui peut être sû en regardant simplement la valeur de retour de <code>search()</code>. <code>'M'</code> correspond à cette expression régulière car le premier <code>M</code> optionnel est obtenu, et que les deux <code>M</code> suivants sont ignorés.
<li><code>'MM'</code> correspond car les deux premiers caractères <code>M</code> sont trouvés, et que le dernier <code>M</code> est ignoré.
<li><code>'MMM'</code> correspond car tous les caractères <code>M</code> sont trouvés.
<li><code>'MMMM'</code> ne correspond pas. Les trois caractères <code>M</code> correspondent, mais l’expression rationnelle insiste pour que la chaine s’arrête immédiatement (à cause du caractère <code>$</code>), mais au lieu de cela, elle trouve un caractère <code>M</code>. Donc <code>search()</code> retourne <code>None</code>.
<li>Il est intéressant de noter que la chaine vide correspond également à l’expresion rationnelle, puisque tous les caractères <code>M</code> sont optionnels.
</ol>
<h3 id=hundreds>Vérifier Les Centaines</h3>
<aside>? rend un schéma optionnel.</aside>
<p>Les centaines sont plus difficiles à gérer que les milliers, car il y a plusieurs façons incompatibles de s’en servir, en dépendant de la valeur.
<ul>
<li><code>100 = C</code>
<li><code>200 = CC</code>
<li><code>300 = CCC</code>
<li><code>400 = CD</code>
<li><code>500 = D</code>
<li><code>600 = DC</code>
<li><code>700 = DCC</code>
<li><code>800 = DCCC</code>
<li><code>900 = CM</code>
</ul>
<p>Il y a donc quatre schémas possibles&nbsp;:
<ul>
<li><code>CM</code>
<li><code>CD</code>
<li>De zéro à trois caractères <code>C</code> (zéro si le chiffre des dizaines est 0)
<li><code>D</code>, suivi par au plus trois caractères <code>C</code>
</ul>
<p>Les deux derniers schémas peuvent être combinés&nbsp;:
<ul>
<li>un <code>D</code> optionnel, suivi par au plus trois caractères <code>C</code>
</ul>
<p>Cet exemple montre comment valider les centaines d’un nombre romain.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?(CM|CD|D?C?C?C?)$'</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCM')</kbd>             <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 01070390></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MD')</kbd>              <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 01073A50></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMCCC')</kbd>          <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 010748A8></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMC')</kbd>            <span class=u>&#x2464;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, '')</kbd>                <span class=u>&#x2465;</span></a>
<samp>&lt;_sre.SRE_Match object at 01071D98></samp></pre>
<ol>
<li>Ce schéma commence de la même façon que le précédent, s’assurant qu’il est au début de la chaine (<code>^</code>), puis les milliers (<code>M?M?M?</code>). Ensuite, on ajoute, entre parenthèses, qui définissent un ensemble de trois schémas mutuellement incompatibles, séparés par des barres verticales&nbsp;: <code>CM</code>, <code>CD</code>, et <code>D?C?C?C?</code> (qui est un <code>D</code> optionnel suivi d’au plus trois caractères <code>C</code>). Le parseur d’expressions régulières vérifiera chacun de ces trois schémas dans l’ordre (de gauche à droite), prendra le premier qui correspondra, et ignorera le reste.
<li><code>'MCM'</code> correspond car le premier <code>M</code> est détecté, les deux caractères <code>M</code> suivants sont ignorés, et le <code>CM</code> correspond (donc les schémas <code>CD</code> et <code>D?C?C?C?</code> ne sont même pas testés). <code>MCM</code> est la représentation de <code>1900</code> en nombres romains.
<li><code>'MD'</code> correspond car le premier <code>M</code> est détecté, les deux <code>M</code> suivants sont ignorés, et <code>D</code> correspond au schéma <code>D?C?C?C?</code> (chacun des trois caractères <code>C</code> est optionnel et est ignoré). <code>MD</code> est la représentation romaine de <code>1500</code>.
<li><code>'MMMCCC'</code> correspond car les trois caractères <code>M</code> sont détectés, et le schéma <code>D?C?C?C?</code> accepte <code>CCC</code> (le <code>D</code> est optionnel et est ignoré). <code>MMMCCC</code> est la représentation romaine de <code>3300</code>.
<li><code>'MCMC'</code> ne correspond pas. Le premier <code>M</code> va, les deux <code>M</code> suivants sont ignorés, et <code>CM</code> est accepté, mais le <code>$</code> refuse d’être validé car vous n’êtes pas à la fin de la chaine (il reste un caractère <code>C</code>). Le <code>C</code> ne correspond <em>pas</em> au schéma <code>D?C?C?C?</code>, car les schémas <code>CM</code> mutuellement incompatibles correspondent déjà à quelque chose.
<li>Il est intéressant de noter que la chaine vide correspond toujours à ce schéma, car tous les caractères <code>M</code> sont optionnels et ignorés, et la chaine vide correspond au schéma <code>D?C?C?C?</code> où tous les caractères sont optionnels et ignorés.
</ol>
<p>Wow ! Vous voyez à quelle vitesse les expressions rationnelles peuvent devenir sales&nbsp;? Et vous n’avez traité que les milliers et les centaines dans les nombres romains. Mais une fois que vous avez fait ça, les dizaines et les unités sont faciles car elles suivent exactement le même schéma. Mais regardons notre schéma d’une autre façon.
<p class=a>&#x2042;

<h2 id=nmsyntax>Utiliser La Syntaxe <code>{n,m}</code></h2>
<aside>{1,4} matches between 1 and 4 occurrences of a pattern.</aside>
<p>In the previous section, you were dealing with a pattern where the same character could be repeated up to three times. There is another way to express this in regular expressions, which some people find more readable. First look at the method we already used in the previous example.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>import re</kbd>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?$'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M')</kbd>     <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MM')</kbd>    <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp>>>> </samp><kbd class=pp>re.search(pattern, 'MMM')</kbd>   <span class=u>&#x2462;</span></a>
<samp class=pp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<a><samp>>>> </samp><kbd class=pp>re.search(pattern, 'MMMM')</kbd>  <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Ceci valide le début de la chaine, puis le premier <code>M</code> optionnel, mais pas les deux <code>M</code> suivants (mais ça passe car ils sont optionnels), et la fin de la chaine.
<li>Ceci valide le début de la chaine, puis les deux premiers <code>M</code> optionnels, mais pas le <code>M</code> suivant (mais ça passe car il est optionnel), et la fin de la chaine.
<li>Ceci valide le début de la chaine, puis les trois caractères <code>M</code> optionnels, et la fin de la chaine.
<li>Ceci valide le début de la chaine, puis les trois caractères <code>M</code> optionnels , mais ne correspond pas à la fin de la chaine (car il y a des <code>M</code> qui ne correspondent pas), donc le schéma ne valide pas et retourne <code>None</code>.
</ol>
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>pattern = '^M{0,3}$'</kbd>        <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M')</kbd>     <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MM')</kbd>    <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EE090></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMM')</kbd>   <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEDA8></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMM')</kbd>  <span class=u>&#x2464;</span></a>
<samp>>>> </samp></pre>
<ol>
<li>Ce schéma dit « Détecte le débit de la chaine, puis entre zéro et trois caractères <code>M</code>, puis la fin de la chaine ». Le 0 et le 3 peuvent être n’importe quel nombre&nbsp;; si vous voulez détecter au moins 1 mais pas plus de trois caractères <code>M</code>, vous pouvez simplement dire <code>M{1,3}</code>.
<li>Ceci détecte le début de la chaine, puis un <code>M</code> sur les trois possibles, puis la fin de la chaine.
<li>Ceci détecte le début de la chaine, puis deux <code>M</code> sur les trois possibles, puis la fin de la chaine.
<li>Ceci détecte le début de la chaine, puis trois <code>M</code> sur les trois possibles, puis la fin de la chaine.
<li>Ceci détecte le début de la chaine, puis trois <code>M</code> sur les trois possibles avant la fin de la chaine. Mais il y en a quatre, donc le schéma ne valide pas et retourner <code>None</code>.
</ol>
<h3 id=tensandones>Vérifier Les Dizaines Et Les Unités</h3>
<p>Maintenant, étendons notre expression rationnelle pour couvrir les dizaines et les unités. Cet exemple montrer comment vérifier les dizaines.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)$'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMXL')</kbd>     <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCML')</kbd>      <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMLX')</kbd>     <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMLXXX')</kbd>   <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMLXXXX')</kbd>  <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Ceci détecte le début de la chaine, puis the first optional <code>M</code>, puis <code>CM</code>, puis <code>XL</code>, puis la fin de la chaine. Souvenez-vous, la syntaxe <code>(A|B|C)</code> correspond à « exactement A, B, <em>ou</em> (exclusif) C ». Vous testez <code>XL</code>, donc vous ignorez les choix <code>XC</code> et <code>L?X?X?X?</code>, puis passez à la fin de la chaine. <code>MCMXL</code> est la représentation romaine de <code>1940</code>.
<li>Ceci détecte le début de la chaine, puis the first optional <code>M</code>, puis <code>CM</code>, puis <code>L?X?X?X?</code>. Le schéma <code>L?X?X?X?</code> détecte le <code>L</code> et passe à la suite en sautant les trois caractères <code>X</code> optionnels. Puis vous passez à la fin de la chaine. <code>MCML</code> est la représentation romaine de <code>1950</code>.
<li>Ceci détecte le début de la chaine, puis the first optional <code>M</code>, puis <code>CM</code>, puis le <code>L</code> optionnel et le <code>X</code> optionnel, saute les deux <code>X</code> suivants optionnels, puis la fin de la chaine. <code>MCMLX</code> est la représentation romaine de <code>1960</code>.
<li>Ceci détecte le début de la chaine, puis the first optional <code>M</code>, puis <code>CM</code>, puis le <code>L</code> optionnel et les trois <code>X</code> optionnels, puis la fin de la chaine. <code>MCMLXXX</code> est la représentation romaine de <code>1980</code>.
<li>Ceci détecte le début de la chaine, puis the first optional <code>M</code>, puis <code>CM</code>, puis le <code>L</code> optionnel et les trois <code>X</code> optionnels, puis <em>ne valide pas</em> car il y a encore un <code>X</code> non validé avant la fin de la chaine. Donc tout le schéma échoue à valider et retourne <code>None</code>. <code>MCMLXXXX</code> n’est pas un nombre romaine valide.
</ol>
<aside>(A|B) correspond soit à A soit à B, mais pas aux deux.</aside>
<p>L’expression pour les unités suit le même schéma. Je vous épargne les détails et vous donne tout de suite le résultat final.
<pre class='nd screen'>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M?M?M?(CM|CD|D?C?C?C?)(XC|XL|L?X?X?X?)(IX|IV|V?I?I?I?)$'</kbd>
</pre><p>Donc, à quoi cela ressemble-t-il si on utilise la syntaxe alternativee <code>{n,m}</code>&nbsp;? Cet exemple montre la nouvelle syntaxe.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>pattern = '^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$'</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MDLV')</kbd>              <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMDCLXVI')</kbd>          <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMDCCCLXXXVIII')</kbd>   <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'I')</kbd>                 <span class=u>&#x2463;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp></pre>
<ol>
<li>This matches the start of the string, then one of a possible three <code>M</code> characters, then <code>D?C{0,3}</code>. Of that, it matches the optional <code>D</code> and zero of three possible <code>C</code> characters. Moving on, it matches <code>L?X{0,3}</code> by matching the optional <code>L</code> and zero of three possible <code>X</code> characters. Then it matches <code>V?I{0,3}</code> by matching the optional <code>V</code> and zero of three possible <code>I</code> characters, and finally the end of the string. <code>MDLV</code> is the Roman numeral representation of <code>1555</code>.
<li>This matches the start of the string, then two of a possible three <code>M</code> characters, then the <code>D?C{0,3}</code> with a <code>D</code> and one of three possible <code>C</code> characters; then <code>L?X{0,3}</code> with an <code>L</code> and one of three possible <code>X</code> characters; then <code>V?I{0,3}</code> with a <code>V</code> and one of three possible <code>I</code> characters; then the end of the string. <code>MMDCLXVI</code> is the Roman numeral representation of <code>2666</code>.
<li>This matches the start of the string, then three out of three <code>M</code> characters, then <code>D?C{0,3}</code> with a <code>D</code> and three out of three <code>C</code> characters; then <code>L?X{0,3}</code> with an <code>L</code> and three out of three <code>X</code> characters; then <code>V?I{0,3}</code> with a <code>V</code> and three out of three <code>I</code> characters; then the end of the string. <code>MMMDCCCLXXXVIII</code> is the Roman numeral representation of <code>3888</code>, and it&#8217;s the longest Roman numeral you can write without extended syntax.
<li>Watch closely. (I feel like a magician. &#8220;Watch closely, kids, I&#8217;m going to pull a rabbit out of my hat.&#8221;)  This matches the start of the string, then zero out of three <code>M</code>, then matches <code>D?C{0,3}</code> by skipping the optional <code>D</code> and matching zero out of three <code>C</code>, then matches <code>L?X{0,3}</code> by skipping the optional <code>L</code> and matching zero out of three <code>X</code>, then matches <code>V?I{0,3}</code> by skipping the optional <code>V</code> and matching one out of three <code>I</code>. Then the end of the string. Whoa.
</ol>
<p>If you followed all that and understood it on the first try, you&#8217;re doing better than I did. Now imagine trying to understand someone else&#8217;s regular expressions, in the middle of a critical function of a large program. Or even imagine coming back to your own regular expressions a few months later. I&#8217;ve done it, and it&#8217;s not a pretty sight.
<p>Now let&#8217;s explore an alternate syntax that can help keep your expressions maintainable.
<p class=a>&#x2042;

<h2 id=verbosere>Verbose Regular Expressions</h2>
<p>So far you&#8217;ve just been dealing with what I&#8217;ll call &#8220;compact&#8221; regular expressions. As you&#8217;ve seen, they are difficult to read, and even if you figure out what one does, that&#8217;s no guarantee that you&#8217;ll be able to understand it six months later. What you really need is inline documentation.
<p>Python allows you to do this with something called <i>verbose regular expressions</i>. A verbose regular expression is different from a compact regular expression in two ways:
<ul>
<li>Whitespace is ignored. Spaces, tabs, and carriage returns are not matched as spaces, tabs, and carriage returns. They&#8217;re not matched at all. (If you want to match a space in a verbose regular expression, you&#8217;ll need to escape it by putting a backslash in front of it.)
<li>Comments are ignored. A comment in a verbose regular expression is just like a comment in Python code: it starts with a <code>#</code> character and goes until the end of the line. In this case it&#8217;s a comment within a multi-line string instead of within your source code, but it works the same way.
</ul>
<p>This will be more clear with an example. Let&#8217;s revisit the compact regular expression you&#8217;ve been working with, and make it a verbose regular expression. This example shows how.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>pattern = '''
    ^                   # beginning of string
    M{0,3}              # thousands - 0 to 3 Ms
    (CM|CD|D?C{0,3})    # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 Cs),
                        #            or 500-800 (D, followed by 0 to 3 Cs)
    (XC|XL|L?X{0,3})    # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 Xs),
                        #        or 50-80 (L, followed by 0 to 3 Xs)
    (IX|IV|V?I{0,3})    # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 Is),
                        #        or 5-8 (V, followed by 0 to 3 Is)
    $                   # end of string
    '''</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M', re.VERBOSE)</kbd>                 <span class=u>&#x2460;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MCMLXXXIX', re.VERBOSE)</kbd>         <span class=u>&#x2461;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'MMMDCCCLXXXVIII', re.VERBOSE)</kbd>   <span class=u>&#x2462;</span></a>
<samp>&lt;_sre.SRE_Match object at 0x008EEB48></samp>
<a><samp class=p>>>> </samp><kbd class=pp>re.search(pattern, 'M')</kbd>                             <span class=u>&#x2463;</span></a></pre>
<ol>
<li>The most important thing to remember when using verbose regular expressions is that you need to pass an extra argument when working with them: <code>re.VERBOSE</code> is a constant defined in the <code>re</code> module that signals that the pattern should be treated as a verbose regular expression. As you can see, this pattern has quite a bit of whitespace (all of which is ignored), and several comments (all of which are ignored). Once you ignore the whitespace and the comments, this is exactly the same regular expression as you saw in the previous section, but it&#8217;s a lot more readable.
<li>This matches the start of the string, then one of a possible three <code>M</code>, then <code>CM</code>, then <code>L</code> and three of a possible three <code>X</code>, then <code>IX</code>, then the end of the string.
<li>This matches the start of the string, then three of a possible three <code>M</code>, then <code>D</code> and three of a possible three <code>C</code>, then <code>L</code> and three of a possible three <code>X</code>, then <code>V</code> and three of a possible three <code>I</code>, then the end of the string.
<li>This does not match. Why?  Because it doesn&#8217;t have the <code>re.VERBOSE</code> flag, so the <code>re.search</code> function is treating the pattern as a compact regular expression, with significant whitespace and literal hash marks. Python can&#8217;t auto-detect whether a regular expression is verbose or not. Python assumes every regular expression is compact unless you explicitly state that it is verbose.
</ol>
<p class=a>&#x2042;

<h2 id=phonenumbers>Case study: Parsing Phone Numbers</h2>
<aside>\d matches any numeric digit (0&ndash;9). \D matches anything but digits.</aside>
<p>So far you&#8217;ve concentrated on matching whole patterns. Either the pattern matches, or it doesn&#8217;t. But regular expressions are much more powerful than that. When a regular expression <em>does</em> match, you can pick out specific pieces of it. You can find out what matched where.
<p>This example came from another real-world problem I encountered, again from a previous day job. The problem: parsing an American phone number. The client wanted to be able to enter the number free-form (in a single field), but then wanted to store the area code, trunk, number, and optionally an extension separately in the company&#8217;s database. I scoured the Web and found many examples of regular expressions that purported to do this, but none of them were permissive enough.
<p>Here are the phone numbers I needed to be able to accept:
<ul>
<li><code>800-555-1212</code>
<li><code>800 555 1212</code>
<li><code>800.555.1212</code>
<li><code>(800) 555-1212</code>
<li><code>1-800-555-1212</code>
<li><code>800-555-1212-1234</code>
<li><code>800-555-1212x1234</code>
<li><code>800-555-1212 ext. 1234</code>
<li><code>work 1-(800) 555.1212 #1234</code>
</ul>
<p>Quite a variety! In each of these cases, I need to know that the area code was <code>800</code>, the trunk was <code>555</code>, and the rest of the phone number was <code>1212</code>. For those with an extension, I need to know that the extension was <code>1234</code>.
<p>Let&#8217;s work through developing a solution for phone number parsing. This example shows the first step.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^(\d{3})-(\d{3})-(\d{4})$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212').groups()</kbd>             <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212-1234')</kbd>                 <span class=u>&#x2462;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212-1234').groups()</kbd>        <span class=u>&#x2463;</span></a>
<samp class=traceback>Traceback (most recent call last):
  File "&lt;stdin>", line 1, in &lt;module>
AttributeError: 'NoneType' object has no attribute 'groups'</samp></pre>
<ol>
<li>Always read regular expressions from left to right. This one matches the beginning of the string, and then <code>(\d{3})</code>. What&#8217;s <code>\d{3}</code>?  Well, <code>\d</code> means &#8220;any numeric digit&#8221; (0 through <code>9</code>). The <code>{3}</code> means &#8220;match exactly three numeric digits&#8221;; it&#8217;s a variation on the <a href=#nmsyntax><code>{n,m} syntax</code></a> you saw earlier. Putting it all in parentheses means &#8220;match exactly three numeric digits, <em>and then remember them as a group that I can ask for later</em>&#8221;. Then match a literal hyphen. Then match another group of exactly three digits. Then another literal hyphen. Then another group of exactly four digits. Then match the end of the string.
<li>To get access to the groups that the regular expression parser remembered along the way, use the <code>groups()</code> method on the object that the <code>search()</code> method returns. It will return a tuple of however many groups were defined in the regular expression. In this case, you defined three groups, one with three digits, one with three digits, and one with four digits.
<li>This regular expression is not the final answer, because it doesn&#8217;t handle a phone number with an extension on the end. For that, you&#8217;ll need to expand the regular expression.
<li>And this is why you should never &#8220;chain&#8221; the <code>search()</code> and <code>groups()</code> methods in production code. If the <code>search()</code> method returns no matches, it returns <a href=native-datatypes.html#none><code>None</code></a>, not a regular expression match object. Calling <code>None.groups()</code> raises a perfectly obvious exception: <code>None</code> doesn&#8217;t have a <code>groups()</code> method. (Of course, it&#8217;s slightly less obvious when you get this exception from deep within your code. Yes, I speak from experience here.)
</ol>
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^(\d{3})-(\d{3})-(\d{4})-(\d+)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212-1234').groups()</kbd>              <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800 555 1212 1234')</kbd>                       <span class=u>&#x2462;</span></a>
<samp class=p>>>> </samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212')</kbd>                            <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>This regular expression is almost identical to the previous one. Just as before, you match the beginning of the string, then a remembered group of three digits, then a hyphen, then a remembered group of three digits, then a hyphen, then a remembered group of four digits. What&#8217;s new is that you then match another hyphen, and a remembered group of one or more digits, then the end of the string.
<li>The <code>groups()</code> method now returns a tuple of four elements, since the regular expression now defines four groups to remember.
<li>Unfortunately, this regular expression is not the final answer either, because it assumes that the different parts of the phone number are separated by hyphens. What if they&#8217;re separated by spaces, or commas, or dots?  You need a more general solution to match several different types of separators.
<li>Oops! Not only does this regular expression not do everything you want, it&#8217;s actually a step backwards, because now you can&#8217;t parse phone numbers <em>without</em> an extension. That&#8217;s not what you wanted at all; if the extension is there, you want to know what it is, but if it&#8217;s not there, you still want to know what the different parts of the main number are.
</ol>
<p>The next example shows the regular expression to handle separators between the different parts of the phone number.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^(\d{3})\D+(\d{3})\D+(\d{4})\D+(\d+)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800 555 1212 1234').groups()</kbd>  <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212-1234').groups()</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('80055512121234')</kbd>              <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212')</kbd>                <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>Hang on to your hat. You&#8217;re matching the beginning of the string, then a group of three digits, then <code>\D+</code>. What the heck is that?  Well, <code>\D</code> matches any character <em>except</em> a numeric digit, and <code>+</code> means &#8220;1 or more&#8221;. So <code>\D+</code> matches one or more characters that are not digits. This is what you&#8217;re using instead of a literal hyphen, to try to match different separators.
<li>Using <code>\D+</code> instead of <code>-</code> means you can now match phone numbers where the parts are separated by spaces instead of hyphens.
<li>Of course, phone numbers separated by hyphens still work too.
<li>Unfortunately, this is still not the final answer, because it assumes that there is a separator at all. What if the phone number is entered without any spaces or hyphens at all?
<li>Oops! This still hasn&#8217;t fixed the problem of requiring extensions. Now you have two problems, but you can solve both of them with the same technique.
</ol>
<p>The next example shows the regular expression for handling phone numbers <em>without</em> separators.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('80055512121234').groups()</kbd>      <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800.555.1212 x1234').groups()</kbd>  <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212').groups()</kbd>        <span class=u>&#x2463;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('(800)5551212 x1234')</kbd>           <span class=u>&#x2464;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>The only change you&#8217;ve made since that last step is changing all the <code>+</code> to <code>*</code>. Instead of <code>\D+</code> between the parts of the phone number, you now match on <code>\D*</code>. Remember that <code>+</code> means &#8220;1 or more&#8221;?  Well, <code>*</code> means &#8220;zero or more&#8221;. So now you should be able to parse phone numbers even when there is no separator character at all.
<li>Lo and behold, it actually works. Why?  You matched the beginning of the string, then a remembered group of three digits (<code>800</code>), then zero non-numeric characters, then a remembered group of three digits (<code>555</code>), then zero non-numeric characters, then a remembered group of four digits (<code>1212</code>), then zero non-numeric characters, then a remembered group of an arbitrary number of digits (<code>1234</code>), then the end of the string.
<li>Other variations work now too: dots instead of hyphens, and both a space and an <code>x</code> before the extension.
<li>Finally, you&#8217;ve solved the other long-standing problem: extensions are optional again. If no extension is found, the <code>groups()</code> method still returns a tuple of four elements, but the fourth element is just an empty string.
<li>I hate to be the bearer of bad news, but you&#8217;re not finished yet. What&#8217;s the problem here?  There&#8217;s an extra character before the area code, but the regular expression assumes that the area code is the first thing at the beginning of the string. No problem, you can use the same technique of &#8220;zero or more non-numeric characters&#8221; to skip over the leading characters before the area code.
</ol>
<p>The next example shows how to handle leading characters in phone numbers.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'^\D*(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('(800)5551212 ext. 1234').groups()</kbd>                  <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212').groups()</kbd>                            <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('work 1-(800) 555.1212 #1234')</kbd>                      <span class=u>&#x2463;</span></a>
<samp class=p>>>> </samp></pre>
<ol>
<li>This is the same as in the previous example, except now you&#8217;re matching <code>\D*</code>, zero or more non-numeric characters, before the first remembered group (the area code). Notice that you&#8217;re not remembering these non-numeric characters (they&#8217;re not in parentheses). If you find them, you&#8217;ll just skip over them and then start remembering the area code whenever you get to it.
<li>You can successfully parse the phone number, even with the leading left parenthesis before the area code. (The right parenthesis after the area code is already handled; it&#8217;s treated as a non-numeric separator and matched by the <code>\D*</code> after the first remembered group.)
<li>Just a sanity check to make sure you haven&#8217;t broken anything that used to work. Since the leading characters are entirely optional, this matches the beginning of the string, then zero non-numeric characters, then a remembered group of three digits (<code>800</code>), then one non-numeric character (the hyphen), then a remembered group of three digits (<code>555</code>), then one non-numeric character (the hyphen), then a remembered group of four digits (<code>1212</code>), then zero non-numeric characters, then a remembered group of zero digits, then the end of the string.
<li>This is where regular expressions make me want to gouge my eyes out with a blunt object. Why doesn&#8217;t this phone number match? Because there&#8217;s a <code>1</code> before the area code, but you assumed that all the leading characters before the area code were non-numeric characters (<code>\D*</code>). Aargh.
</ol>
<p>Let&#8217;s back up for a second. So far the regular expressions have all matched from the beginning of the string. But now you see that there may be an indeterminate amount of stuff at the beginning of the string that you want to ignore. Rather than trying to match it all just so you can skip over it, let&#8217;s take a different approach: don&#8217;t explicitly match the beginning of the string at all. This approach is shown in the next example.
<pre class=screen>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'(\d{3})\D*(\d{3})\D*(\d{4})\D*(\d*)$')</kbd>  <span class=u>&#x2460;</span></a>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('work 1-(800) 555.1212 #1234').groups()</kbd>         <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212').groups()</kbd>                        <span class=u>&#x2462;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('80055512121234').groups()</kbd>                      <span class=u>&#x2463;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp></pre>
<ol>
<li>Note the lack of <code>^</code> in this regular expression. You are not matching the beginning of the string anymore. There&#8217;s nothing that says you need to match the entire input with your regular expression. The regular expression engine will do the hard work of figuring out where the input string starts to match, and go from there.
<li>Now you can successfully parse a phone number that includes leading characters and a leading digit, plus any number of any kind of separators around each part of the phone number.
<li>Sanity check. This still works.
<li>That still works too.
</ol>
<p>See how quickly a regular expression can get out of control?  Take a quick glance at any of the previous iterations. Can you tell the difference between one and the next?
<p>While you still understand the final answer (and it is the final answer; if you&#8217;ve discovered a case it doesn&#8217;t handle, I don&#8217;t want to know about it), let&#8217;s write it out as a verbose regular expression, before you forget why you made the choices you made.
<pre class=screen>
<samp class=p>>>> </samp><kbd class=pp>phonePattern = re.compile(r'''
                # don't match beginning of string, number can start anywhere
    (\d{3})     # area code is 3 digits (e.g. '800')
    \D*         # optional separator is any number of non-digits
    (\d{3})     # trunk is 3 digits (e.g. '555')
    \D*         # optional separator
    (\d{4})     # rest of number is 4 digits (e.g. '1212')
    \D*         # optional separator
    (\d*)       # extension is optional and can be any number of digits
    $           # end of string
    ''', re.VERBOSE)</kbd>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('work 1-(800) 555.1212 #1234').groups()</kbd>  <span class=u>&#x2460;</span></a>
<samp class=pp>('800', '555', '1212', '1234')</samp>
<a><samp class=p>>>> </samp><kbd class=pp>phonePattern.search('800-555-1212')</kbd>                          <span class=u>&#x2461;</span></a>
<samp class=pp>('800', '555', '1212', '')</samp></pre>
<ol>
<li>Other than being spread out over multiple lines, this is exactly the same regular expression as the last step, so it&#8217;s no surprise that it parses the same inputs.
<li>Final sanity check. Yes, this still works. You&#8217;re done.
</ol>
<p class=a>&#x2042;

<h2 id=summary>Summary</h2>
<p>This is just the tiniest tip of the iceberg of what regular expressions can do. In other words, even though you&#8217;re completely overwhelmed by them now, believe me, you ain&#8217;t seen nothing yet.
<p>You should now be familiar with the following techniques:
<ul>
<li><code>^</code> matches the beginning of a string.
<li><code>$</code> matches the end of a string.
<li><code>\b</code> matches a word boundary.
<li><code>\d</code> matches any numeric digit.
<li><code>\D</code> matches any non-numeric character.
<li><code>x?</code> matches an optional <code>x</code> character (in other words, it matches an <code>x</code> zero or one times).
<li><code>x*</code> matches <code>x</code> zero or more times.
<li><code>x+</code> matches <code>x</code> one or more times.
<li><code>x{n,m}</code> matches an <code>x</code> character at least <code>n</code> times, but not more than <code>m</code> times.
<li><code>(a|b|c)</code> matches exactly one of <code>a</code>, <code>b</code> or <code>c</code>.
<li><code>(x)</code> in general is a <em>remembered group</em>. You can get the value of what matched by using the <code>groups()</code> method of the object returned by <code>re.search</code>.
</ul>
<p>Regular expressions are extremely powerful, but they are not the correct solution for every problem. You should learn enough about them to know when they are appropriate, when they will solve your problems, and when they will cause more problems than they solve.
<p class=v><a href=strings.html rel=prev title='back to &#8220;Strings&#8221;'><span class=u>&#x261C;</span></a> <a href=generators.html rel=next title='onward to &#8220;Closures &amp; Generators&#8221;'><span class=u>&#x261E;</span></a>
<p class=c>&copy; 2001&ndash;11 <a href=about.html>Mark Pilgrim</a>
<script src=j/jquery.js></script>
<script src=j/prettify.js></script>
<script src=j/dip3.js></script>
